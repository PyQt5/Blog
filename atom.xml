<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PyQt5</title>
  
  <subtitle>学习交流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pyqt5.com/"/>
  <updated>2019-12-26T12:14:56.491Z</updated>
  <id>https://pyqt5.com/</id>
  
  <author>
    <name>PyQt5</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PyQt学习心得</title>
    <link href="https://pyqt5.com/studynotes.html"/>
    <id>https://pyqt5.com/studynotes.html</id>
    <published>2019-08-26T01:00:00.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>在学习PyQt的过程中由于资料的缺乏或者没有中文导致大多数人感叹资料太少，学习困难，又或者急于求进，赶鸭子上架的情况，此时有系统的学习方法很重要。每个人都需要有自己的学习方法，别人的学习方法并不一定适合自己但可以采纳一些。笔者在这里列举了一些当初自己自学的一些心得和方法，希望帮助大家建立一套自己的学习PyQt的方法，提高自身的学习能力。<br><a id="more"></a></p><h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><p>在学习和使用PyQt之前需要熟练使用Python，经过对QQ群里经常提问的问题的分析，发现大部分人对Python中的基础知识掌握不牢固导致很多基础问题，如果要想更好的使用Python以及它的扩展必需要进行系统的学习。这里列举一下常用的知识点。</p><ol><li>类　　　　　　　 　<a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">参考资料</a></li><li>类的继承</li><li>类的多继承</li><li>类方法重写　　　　 <a href="https://www.runoob.com/w3cnote/python-extends-init.html" target="_blank" rel="noopener">参考资料</a></li><li>类中的super函数　　<a href="https://www.runoob.com/python/python-func-super.html" target="_blank" rel="noopener">参考资料</a></li><li>函数调用/参数类型</li><li>对象调用(参考第1点)</li></ol><p>必须熟练掌握上面的知识点后入门PyQt才比较容易，如果初学者对上面的知识点还不是很了解，本文不适合继续往下阅读。</p><h2 id="设计师"><a href="#设计师" class="headerlink" title="设计师"></a>设计师</h2><p>Qt 设计师除了方便快速设计一些简单的界面外，其实笔者觉得更大的作用在于帮助用户熟悉各类控件、属性、信号等</p><ol><li>这里建议初学者不要急于求成，打开设计师新建一个<code>Widget</code>的窗口，比如</li></ol><p><img src="/images/studynotes/desiger_create.png" alt="desiger_create"></p><ol start="2"><li>然后把左侧的所有控件挨个拖动到中间的窗口中，比如这里拖动一个<strong>Push Button</strong>按钮</li></ol><p><img src="/images/studynotes/desiger_drag.png" alt="desiger_drag"></p><ol start="3"><li>在设计师右下角的属性编辑器中列举了该控件的所有父类，意味着可以调用和重写父类的所有方法，建议初学者把这个属性编辑器的所有属性挨个调整看看效果，部分控件可能需要<strong>Ctrl+R</strong>预览界面才能看到，同时像<strong>QListWidget，QTreeWidget，QTableWidget</strong>等某些控件需要在控件上右键增加数据才可以</li></ol><p><img src="/images/studynotes/desiger_property.png" alt="desiger_property"><br><img src="/images/studynotes/desiger_property2.png" alt="desiger_property2"></p><ol start="4"><li>两个控件之间简单的信号槽关联可以通过设计师快速的设置</li></ol><p><img src="/images/studynotes/desiger_signal.png" alt="desiger_signal"><br><img src="/images/studynotes/desiger_signal2.png" alt="desiger_signal2"></p><ol start="5"><li>提高进阶的方法，当你需要手动写代码实现界面的时候，不妨把UI文件转出PY文件，看看是如何构造的（这里涉及到布局等知识见后文）</li></ol><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Qt界面提供了方便的4种基本布局，<strong>QVboxLayout，QHboxLayout，QFormLayout，QGridLayout</strong>，初学者需要数量掌握这4种布局外加2种拉伸器（占位挤压）</p><p>首先需要知道Qt界面的中控件的层级顺序以及parent，parent的作用既作为子控件的父元素也可以自动管理Qt的对象（具体可以搜索下关于 Qt parent的资料）</p><ol><li>在没有布局的情况下，在设计师中拖动摆放的控件是一层一层的叠加覆盖，此时每个添加的子控件的parent都是最外层的控件</li></ol><p><img src="/images/studynotes/desiger_stack.png" alt="desiger_stack"></p><ol start="2"><li>如果需要界面中的控件自动适应高度宽度，此时则需要使用4种布局来包裹里面的子控件，注意的是：布局不是控件不能设置高度宽度和样式等，是一个抽象的东西，就好比是一根橡皮筋包裹几个矩形的物品；布局也可以设置一些属性（在设计师属性编辑器中），比如设置两者直接的间距，设置距离上下左右的间距，设置比例等</li></ol><p><img src="/images/studynotes/desiger_layout.png" alt="desiger_layout"></p><ol start="3"><li>在没有布局或者有布局的时候。可以添加容器控件（<strong>QWidget，QFrame，QGroupBox，QScrollArea，QToolBox，QTabWidget，QStackedWidget，QMidArea，QDockWidget</strong>）这些容器可以放置子控件，从而循环嵌套。</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在PyQt5.5的时候自带了一个例子文件夹（后面的版本没有的话可以下载PyQt5源码，里面有个examples文件夹），想要熟练的掌握PyQt还需要从自带的例子中学习，必须要每个例子都运行一次然后看看这个例子实现了什么，这样才能记忆深刻。<br>同时很多开发者在<a href="https://github.com/PyQt5/PyQt" target="_blank" rel="noopener">https://github.com/PyQt5/PyQt</a>分享了各类进阶例子，同时也欢迎大家共同完善该项目，提供更多更好的例子。另外也可以下载该项目的客户端<a href="https://github.com/PyQt5/PyQtClient/releases" target="_blank" rel="noopener">PyQtClient</a>软件，支持运行其中的例子</p><p>建议在更深入的学习PyQt之前多看看一些例子。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>接下来要说的就是Qt的api文档，<a href="https://doc.qt.io/qt-5/classes.html" target="_blank" rel="noopener">官网文档</a>，这里其实不要害怕是英文就不想看，觉得看不懂了，其实官网的文档还是比较简洁的，而且函数名也比较直观就能知道意思。也可以用谷歌浏览器打开右键翻译，基本上都能看懂。笔者前期写过一篇<a href="/viewapi.html">如何查阅Qt文档</a>的文档可以阅读学习一番。</p><p>这里就拿<a href="https://doc.qt.io/qt-5/qwebengineview.html" target="_blank" rel="noopener">QWebEngineView</a>举一个例子，首先初学者在使用这个浏览器控件时候，会有诸多的问题比如：Cookie，拦截器等就不知道如何去调用函数来设置</p><ol><li>首先打开官网文档 <a href="https://doc.qt.io/qt-5/qwebengineview.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qwebengineview.html</a>，可以看到只有少量的函数可以调用，寻找一番并没有发现和Cookie相关的东西，这个时候就需要把重点放在有特俗返回值的函数上，比如：<pre><code class="c++">QWebEngineHistory *              history() constQWebEnginePage *              page() constQWebEngineSettings *          settings() const</code></pre></li></ol><p>这三个函数返回了一个类实例，就意味着可以调用其中的方法。</p><ol start="2"><li><p>点击<strong>page()</strong>打开 <a href="https://doc.qt.io/qt-5/qwebenginepage.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qwebenginepage.html</a>，发现没有cookie相关的东西，只有<strong>QWebEngineProfile *    profile() const</strong>这个函数比较可疑。</p></li><li><p>点击<strong>profile()</strong>打开 <a href="https://doc.qt.io/qt-5/qwebengineprofile.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qwebengineprofile.html</a>，在浏览器中搜索<code>cookie</code>发现这个类中包含大量和cookie相关的东西，比如：<strong>QWebEngineCookieStore *    cookieStore()`</strong>从名字上可以猜测大概意思为cookie储存</p></li><li><p>点击<strong>cookieStore()</strong>打开 <a href="https://doc.qt.io/qt-5/qwebenginecookiestore.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qwebenginecookiestore.html</a>，此时就会发现这个类里面包含了删除和设置cookie的方法。</p></li><li><p>但是找到了这些方法后，面对初学者又一个问题来了，该如何去用？根据上面4点整理一下，把他们当做简单的Python对象，方法和操作方法和class一样的。</p></li></ol><pre><code class="python">self.webview = QWebEngineView()# 得到pagepage = self.webview.page()# 得到profileprofile = page.profile()# 得到cookieStorecookieStore = profile.cookieStore()# 清空cookiecookieStore.deleteAllCookies()# 用简短代码来表达就是cookieStore = self.webview.page().profile().cookieStore()cookieStore.deleteAllCookies()</code></pre><h2 id="异常调试"><a href="#异常调试" class="headerlink" title="异常调试"></a>异常调试</h2><p>可能有时候由于粗心，或者调用了一些非法函数，参数错误等会导致程序出现一些异常，首先第一步复制最后一行的错误去百度或者谷歌搜索，大多时候能找到问题所在。其次如果搜索不到或者自己的异常可能是由于某个变量的值不对引起的，就需要在编辑器中打断点使用DEBUG模式调试变量值（如果不会可以采用麻烦一点的办法：用<code>print</code>打印出变量值）</p><p>遇到问题后首先需要自己多调试排查问题，不要一遇到问题就去问，自己多尝试一个一个排查直到找到问题所在并解决，这也是一种提高自身能力的地方。</p><h2 id="检索资料"><a href="#检索资料" class="headerlink" title="检索资料"></a>检索资料</h2><p>作为一个开发人员确实需要具备查阅文档、查询资料等基础技能，会为自己的开发带来很大的帮助，要善于搜索，通过不同的方式去搜索才能找到自己需要的东西。信息检索是每个程序猿必备的能力之一，其好处在于可以更快更准确的在茫茫网络海洋中找到自己所需要的东西，这个过程需要长期不断积累和练习。</p><ol><li>中文搜索引擎：采用多个关键词 以空格分开搜索，如：PyQt 拖拽</li><li>英文搜索引擎：采用多个关键词 以空格分开搜索，如：PyQt Drag Drop</li></ol><h2 id="片尾"><a href="#片尾" class="headerlink" title="片尾"></a>片尾</h2><p>好了，笔者基本上的学习过程就整理如上，这并不是说每个人都适合这样的方法，但至少笔者是这样一步一步走过来的。当你养成了一个学习、发现和解决问题的好习惯时就会慢慢得心应手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习PyQt的过程中由于资料的缺乏或者没有中文导致大多数人感叹资料太少，学习困难，又或者急于求进，赶鸭子上架的情况，此时有系统的学习方法很重要。每个人都需要有自己的学习方法，别人的学习方法并不一定适合自己但可以采纳一些。笔者在这里列举了一些当初自己自学的一些心得和方法，希望帮助大家建立一套自己的学习PyQt的方法，提高自身的学习能力。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://pyqt5.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
  </entry>
  
  <entry>
    <title>python 状态机模块 　</title>
    <link href="https://pyqt5.com/python_statemachine.html"/>
    <id>https://pyqt5.com/python_statemachine.html</id>
    <published>2019-07-17T09:03:33.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>用状态来取代if…else判断。</p><a id="more"></a><p>GUI涉及到挺多的状态改变 , 以前一直用 if…else 来判断 , 最近读了设计模式 ,发现有个状态模式 , 随后发现了状态机这个东西 .</p><p>python的状态机模块挺多的 , 不过好像很多都不更新了.<br>推荐2个状态机模块 , 但是也没有太深入的使用经验 , 就跑跑例子 , 以后有更详细的pyqt例子再补上 .</p><p>1: <code>pip install python-statemachine</code></p><p>官方例子 : <a href="https://github.com/fgmacedo/python-statemachine" target="_blank" rel="noopener">https://github.com/fgmacedo/python-statemachine</a></p><p>2.<code>pip install state_machine</code></p><p>官方例子 : <a href="https://github.com/jtushman/state_machine" target="_blank" rel="noopener">https://github.com/jtushman/state_machine</a></p><p>1的 最近一次更新在6个月以前 , 使用<code>类继承</code>和<code>mixin</code>方式 , 不过有些地方不如2个人性化;</p><p>2的设计更人性化一些 , 包括状态改变<code>before</code>和 <code>after</code> , 不过由于是装饰器实现的动态增加属性 , 有些地方编辑器智能提示可能就靠不上了.</p><p>两者实现实现方式不一样 , 有兴趣可以读读源码 .</p><ol start="3"><li>qt内置状态机框架</li></ol><p><a href="https://blog.csdn.net/amnes1a/article/details/62418196" target="_blank" rel="noopener">https://blog.csdn.net/amnes1a/article/details/62418196</a></p><p><a href="https://blog.csdn.net/dongfenghuojian/article/details/78187131" target="_blank" rel="noopener">https://blog.csdn.net/dongfenghuojian/article/details/78187131</a></p><p><a href="http://blog.sina.com.cn/s/articlelist_3284623693_0_1.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/articlelist_3284623693_0_1.html</a> (系列教程)    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用状态来取代if…else判断。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://pyqt5.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Python" scheme="https://pyqt5.com/tags/Python/"/>
    
      <category term="python 状态机" scheme="https://pyqt5.com/tags/python-%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>在pyqt中使用python全局钩子模块</title>
    <link href="https://pyqt5.com/pyqt5_hook_key.html"/>
    <id>https://pyqt5.com/pyqt5_hook_key.html</id>
    <published>2019-07-06T17:37:22.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>在某些时候需要为自己的软件增加全局键盘监听，比如软件最小化隐藏后可以通过热键唤醒，又或者比如像QQ一样可以全局热键截图。这里介绍几个方法实现在PyQt中使用Python全局钩子模块实现全局热键功能。</p><a id="more"></a><ol><li><code>pyHook3</code></li></ol><p>安装命令 : <code>pip install pyhook3</code></p><p><a href="https://blog.csdn.net/q871063970/article/details/86648386" target="_blank" rel="noopener">https://blog.csdn.net/q871063970/article/details/86648386</a></p><p>似乎将pyhook支持py3版本的了?  没有太多研究.</p><p>缺点: 只支持win平台.</p><p>2.<code>keyboard</code> &amp; <code>mouse</code></p><p>安装命令: <code>pip install keyboard mouse</code></p><pre><code>from PyQt5 import  QtGui, QtWidgets, QtCorefrom PyQt5.QtCore import *from PyQt5.QtGui import *from PyQt5.QtWidgets import *import keyboardclass Window(QWidget):    def __init__(self, *args, **kwargs):        super(Window, self).__init__(*args, **kwargs)        layout = QVBoxLayout(self)        self.testBtn = QPushButton(self)        layout.addWidget(self.testBtn)        keyboard.add_hotkey(&#39;ctrl+shift+x&#39;, lambda:print(&#39;triggered&#39;, &#39;hotkey&#39;))        keyboard.add_hotkey(&#39;ctrl+shift+c&#39;, self.abc,args=(&#39;aa&#39;,&quot;bb&quot;,&quot;cc&quot;))    def abc(self,a,b,c):        print(a,b,c)if __name__ == &#39;__main__&#39;:    import sys    from PyQt5.QtWidgets import QApplication    app = QApplication(sys.argv)    w = Window()    w.show()    sys.exit(app.exec_())</code></pre><p>更详细例子 : <a href="https://github.com/PyQt5/PyQt/blob/63c6376358acb1863313fb5593097e6e0210cad6/Test/%E5%85%A8%E5%B1%80%E7%83%AD%E9%94%AE/HotKey.py" target="_blank" rel="noopener">pyqt中使用keyboard全局热键</a></p><p>优点: 跨平台 ;</p><p>缺点: 模块名字取得太差, 不容易被发现.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些时候需要为自己的软件增加全局键盘监听，比如软件最小化隐藏后可以通过热键唤醒，又或者比如像QQ一样可以全局热键截图。这里介绍几个方法实现在PyQt中使用Python全局钩子模块实现全局热键功能。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://pyqt5.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Python" scheme="https://pyqt5.com/tags/Python/"/>
    
      <category term="pyqt hook key" scheme="https://pyqt5.com/tags/pyqt-hook-key/"/>
    
  </entry>
  
  <entry>
    <title>像读文章一样读源码</title>
    <link href="https://pyqt5.com/read_open_source.html"/>
    <id>https://pyqt5.com/read_open_source.html</id>
    <published>2019-07-06T17:37:22.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>使用snoop, 像读文章一样读源码。</p><a id="more"></a><p>不得不说 开源项目没有一个提纲 ， 看起来太操蛋了。问了作者， 作者说 ， 你运行下主函数， 然后慢慢跟 。。。<br><img src="https://upload-images.jianshu.io/upload_images/10769157-b274b7acaecf49bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>没有目的地概览 ， 不知不觉就追究到细节里面去了。</p><p><img src="https://upload-images.jianshu.io/upload_images/10769157-1304cc87fcd42cae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>所以这一篇文章的目地就是 ， 如何在没有提纲的情况下 ， 能更好的只关注流程 ， 而不是细节 。 </p><p>开始 ： </p><ol><li>python DEBUG 模块介绍 :<br>　前段时间看过挺多文章提到pysoonper这个调试模块 , 有兴趣的可以百度一下.<br>个人尝试了一下 , 篇幅过大的DEBUG不适合用 pysoonper , 因为没有缩进 !<br>　这几天偶然遇到一个二次封装的模块<a href="[https://github.com/alexmojaki/snoop](https://github.com/alexmojaki/snoop">snoop</a><br>), 完美地解决了这个问题.</li><li>操作步骤 : </li></ol><ul><li>1 .  在<code>eric6.py</code>的<code>main()</code>函数上加snoop装饰器;<br><img src="https://upload-images.jianshu.io/upload_images/10769157-74129f6a6c303b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>2 . 用vscode 打开 <code>eric6start_.log</code>  文件 (8层深度log文件34W行, pycharm对大文件支持很差);<br><img src="https://upload-images.jianshu.io/upload_images/10769157-ae946c117a082c24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="log文件"></li></ul><p>发现可以折叠 ， 但是最大可折叠等级只到5级 ， 而且无法对对应等级折叠 ， 有点遗憾 。也许是.log格式选得不太好， 不知道是否有更好的后缀格式。</p><ul><li>3 . vscode配置log文件关键字高亮；<br>安装高亮插件<br><img src="https://upload-images.jianshu.io/upload_images/10769157-8f6fee2356d7071d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>配置高亮关键字<br><img src="https://upload-images.jianshu.io/upload_images/10769157-a135fd015409b3da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>将<code>call</code> 和<code>return</code> 给加进去.</p><ul><li>4 .增加阶段关键字；</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10769157-c39d01a02149e808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eric6启动阶段"></p><p><img src="https://upload-images.jianshu.io/upload_images/10769157-aef5704c36824dcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>加<code>#000</code> 是为了方便搜索 。<br>需要自己手动折叠 。<br>可以发现 每个<code>splash.showMessage()</code> 都是一个阶段 ， 展开折叠之后就是每个阶段具体执行细节 。 </p><hr><h3 id="ps-vscode-阅读log文件还是有一些不方便的地方-除了在2-中提到的-还有包括关闭文件再打开-折叠状态不会保留-有其他更好的方式-请留言告诉我-谢谢"><a href="#ps-vscode-阅读log文件还是有一些不方便的地方-除了在2-中提到的-还有包括关闭文件再打开-折叠状态不会保留-有其他更好的方式-请留言告诉我-谢谢" class="headerlink" title="ps: vscode 阅读log文件还是有一些不方便的地方 , 除了在2.中提到的, 还有包括关闭文件再打开, 折叠状态不会保留 , 有其他更好的方式 请留言告诉我 , 谢谢."></a>ps: vscode 阅读log文件还是有一些不方便的地方 , 除了在2.中提到的, 还有包括关闭文件再打开, 折叠状态不会保留 , 有其他更好的方式 请留言告诉我 , 谢谢.</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用snoop, 像读文章一样读源码。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://pyqt5.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Python" scheme="https://pyqt5.com/tags/Python/"/>
    
      <category term="debug" scheme="https://pyqt5.com/tags/debug/"/>
    
      <category term="snoop" scheme="https://pyqt5.com/tags/snoop/"/>
    
  </entry>
  
  <entry>
    <title>python 获取子进程print信息 　</title>
    <link href="https://pyqt5.com/pyqt_get_subprocess_pipeline.html"/>
    <id>https://pyqt5.com/pyqt_get_subprocess_pipeline.html</id>
    <published>2019-05-24T06:39:44.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>在PyQt中使用子线程读取子进程Python脚本的print输出流内容。</p><a id="more"></a><p>问题所在：</p><p><img src="https://i.loli.net/2019/05/24/5ce793171984f27031.png" alt="image.png"></p><p>如果模块都由自己开发， 正常操作 </p><p><img src="https://i.loli.net/2019/05/24/5ce7933994a0090037.png" alt="image.png"></p><p>但是因为不能改, 所以只能拦截：<br>代码：</p><pre><code class="python">pythonPath = self.pythonPath_cb.currentText()if suffix == &quot;py&quot;:    # 首次    self.pyCommand = [pythonPath, path]    self.modifiedReloadPython(path)def modifiedReloadPython(self, path_):    os.chdir(os.path.dirname(path_))    # 子进程调用    self.p = subprocess.Popen(self.pyCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)    # self.stdoutWorker.p = self.p    self.stdoutWorker = Worker(self.p)    self.stdoutWorker.stdout_signal.connect(lambda x: self.error_te.append(&quot;PYDEBUG:\n&quot; + x))    self.stdoutWorker.start()class Worker(QThread):    stdout_signal = pyqtSignal(str)    def __init__(self, p, parent=None):        super().__init__(parent)        self.p = p    def run(self):        while True:            QApplication.processEvents()            if self.p is not None:                line = self.p.stdout.readline()                # line = line.strip()                if line != b&#39;&#39;:                    try:                        info = line.decode()                        self.stdout_signal.emit(info)                    except:                        self.stdout_signal.emit(repr(line))</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PyQt中使用子线程读取子进程Python脚本的print输出流内容。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://pyqt5.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Python" scheme="https://pyqt5.com/tags/Python/"/>
    
      <category term="subprocess.Popen" scheme="https://pyqt5.com/tags/subprocess-Popen/"/>
    
      <category term="拦截print" scheme="https://pyqt5.com/tags/%E6%8B%A6%E6%88%AAprint/"/>
    
  </entry>
  
  <entry>
    <title>QtWebkit和QWebEngineView与Javascript交互</title>
    <link href="https://pyqt5.com/qtwebjs.html"/>
    <id>https://pyqt5.com/qtwebjs.html</id>
    <published>2019-05-22T03:30:36.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>以前还是<code>QWebView</code>的时候和<code>Javascript</code>交互起来很方便，但是到了Qt5.6以后改用了<code>QWebEngineView</code>，并通过其提供的<code>qwebchannel.js</code>来进行交互。可能是由于刚出来的原因，这玩意儿有个bug就是必须在每次加载页面的时候手动注入，跳转页面后就失效了，需要手动注入，目前有没有修复具体未测试。这里对<code>QWebView</code>和<code>QWebEngineView</code>与Js交互都做了一个示例。<br><a id="more"></a></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li>针对<code>QWebView</code>通过<code>QWebFrame</code>的<code>addToJavaScriptWindowObject</code>把对象传递到<code>Javascript</code>中</li><li>针对<code>QWebEngineView</code>通过<code>QWebChannel.registerObject(&#39;Bridge&#39;, QObject)</code>把对象传递到<code>Javascript</code>中</li><li>可以通过<code>@pyqtSlot</code>装饰器来申明该方法可以暴露给<code>Javascript</code>调用</li></ol><pre><code class="python">@pyqtSlot(str)def callFromJs(self, text):    QMessageBox.information(self, &quot;提示&quot;, &quot;来自js调用：{}&quot;.format(text))</code></pre><ol start="4"><li>针对<code>QWebView</code>在<code>Javascript</code>中获取该对象，可以通过该对象对窗口属性以及信号和暴露出的方法进行调用</li></ol><pre><code class="javascript">// 这里绑定窗口的标题变化信号（这个信号是由QWidget内部的）Bridge.windowTitleChanged.connect({fun: function(title) {    showLog(&quot;标题被修改为：&quot; + title);}}, &quot;fun&quot;);// 绑定自定义的信号customSignalBridge.customSignal.connect({fun: function(text) {    showLog(&quot;收到自定义信号内容：&quot; + text);}}, &quot;fun&quot;);</code></pre><ol start="5"><li>针对<code>QWebEngineView</code>在<code>Javascript</code>中获取该对象，可以通过该对象对窗口属性以及信号和暴露出的方法进行调用</li></ol><pre><code class="javascript">new QWebChannel(qt.webChannelTransport,    function(channel) {        window.Bridge = channel.objects.Bridge;        // 这里绑定窗口的标题变化信号（这个信号是由QWidget内部的）        Bridge.windowTitleChanged.connect(function(title) {            showLog(&quot;标题被修改为：&quot; + title);        });        // 绑定自定义的信号customSignal        Bridge.customSignal.connect(function(text) {           showLog(&quot;收到自定义信号内容：&quot; + text);        });    });</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>QWebView</code>： <a href="https://github.com/PyQt5/PyQt/blob/master/QWebView/JsSignals.py" target="_blank" rel="noopener">https://github.com/PyQt5/PyQt/blob/master/QWebView/JsSignals.py</a></p><p><code>QWebEngineView</code>： <a href="https://github.com/PyQt5/PyQt/blob/master/QWebEngineView/JsSignals.py" target="_blank" rel="noopener">https://github.com/PyQt5/PyQt/blob/master/QWebEngineView/JsSignals.py</a></p><ol><li>针对<code>QWebView</code>的核心实现</li></ol><pre><code class="python">class WebView(QWebView):    customSignal = pyqtSignal(str)    def __init__(self, *args, **kwargs):        super(WebView, self).__init__(*args, **kwargs)        self.initSettings()        # 暴露接口对象        self.page().mainFrame().javaScriptWindowObjectCleared.connect(self._exposeInterface)    def _exposeInterface(self):        &quot;&quot;&quot;向Js暴露调用本地方法接口        &quot;&quot;&quot;        self.page().mainFrame().addToJavaScriptWindowObject(&#39;Bridge&#39;, self)    # 注意pyqtSlot用于把该函数暴露给js可以调用    @pyqtSlot(str)    def callFromJs(self, text):        QMessageBox.information(self, &quot;提示&quot;, &quot;来自js调用：{}&quot;.format(text))    def sendCustomSignal(self):        # 发送自定义信号        self.customSignal.emit(&#39;当前时间: &#39; + str(time()))</code></pre><ol start="2"><li>针对<code>QWebEngineView</code>的核心实现</li></ol><pre><code class="python">class WebEngineView(QWebEngineView):    customSignal = pyqtSignal(str)    def __init__(self, *args, **kwargs):        super(WebEngineView, self).__init__(*args, **kwargs)        self.channel = QWebChannel(self)        # 把自身对象传递进去        self.channel.registerObject(&#39;Bridge&#39;, self)        # 设置交互接口        self.page().setWebChannel(self.channel)    # 注意pyqtSlot用于把该函数暴露给js可以调用    @pyqtSlot(str)    def callFromJs(self, text):        QMessageBox.information(self, &quot;提示&quot;, &quot;来自js调用：{}&quot;.format(text))    def sendCustomSignal(self):        # 发送自定义信号        self.customSignal.emit(&#39;当前时间: &#39; + str(time()))</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://github.com/PyQt5/PyQt/raw/master/QWebEngineView/ScreenShot/JsSignals.gif" alt="JsSignals"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前还是&lt;code&gt;QWebView&lt;/code&gt;的时候和&lt;code&gt;Javascript&lt;/code&gt;交互起来很方便，但是到了Qt5.6以后改用了&lt;code&gt;QWebEngineView&lt;/code&gt;，并通过其提供的&lt;code&gt;qwebchannel.js&lt;/code&gt;来进行交互。可能是由于刚出来的原因，这玩意儿有个bug就是必须在每次加载页面的时候手动注入，跳转页面后就失效了，需要手动注入，目前有没有修复具体未测试。这里对&lt;code&gt;QWebView&lt;/code&gt;和&lt;code&gt;QWebEngineView&lt;/code&gt;与Js交互都做了一个示例。&lt;br&gt;
    
    </summary>
    
      <category term="例子" scheme="https://pyqt5.com/categories/%E4%BE%8B%E5%AD%90/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="QWebView" scheme="https://pyqt5.com/tags/QWebView/"/>
    
      <category term="QWebEngineView" scheme="https://pyqt5.com/tags/QWebEngineView/"/>
    
      <category term="浏览器" scheme="https://pyqt5.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5窗口翻转动画</title>
    <link href="https://pyqt5.com/flipwidgetanimation.html"/>
    <id>https://pyqt5.com/flipwidgetanimation.html</id>
    <published>2019-05-15T14:48:00.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>QQ的界面一直是用来模仿练习做界面的好东西，这里就有一个类似QQ登录界面的实现翻转效果，当然这里并没有用两个窗口去做，而是用了<code>QStackedWidget</code>包含两个控件做切换，同时单独使用一个窗口做动画绘制。<br><a id="more"></a></p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><ol><li>用了两个<code>QLabel</code>来显示模拟的图片界面，并实现鼠标点击模拟真实的窗口对应位置点击</li><li>用了<code>QStackedWidget</code>来存放上面的两个界面<code>QLabel</code></li><li>点击切换时主要是对上面的两个界面进行截图并传递给翻转动画窗口</li><li>通过<code>setWindowOpacity</code>控制主窗口的显示隐藏（保留任务栏），当然也可以用<code>hide</code></li><li>动画窗口<code>FlipWidget.py</code>主要实现两张图片的翻转显示，考虑到0-90和90-180之前的情况，以及图片的缩放动画</li></ol><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><ol><li>主要是在<code>paintEvent</code>方法中使用<code>QTransform</code>对<code>QPainter</code>进行圆心变换以及<code>rotate</code>设置翻转角度</li><li>同时根据翻转的角度范围对图片进行切换和缩放</li></ol><pre><code class="python">def paintEvent(self, event):    super(FlipWidget, self).paintEvent(event)    if hasattr(self, &#39;image1&#39;) and hasattr(self, &#39;image2&#39;) and self.isVisible():        painter = QPainter(self)        painter.setRenderHint(QPainter.Antialiasing, True)        painter.setRenderHint(QPainter.SmoothPixmapTransform, True)        # 变换        transform = QTransform()        # 把圆心设置为矩形中心        transform.translate(self.width() / 2, self.height() / 2)        if self._angle &gt;= -90 and self._angle &lt;= 90:            # 当翻转角度在90范围内显示第一张图，且从大图缩放到小图的过程            painter.save()            # 设置翻转角度            transform.rotate(self._angle, Qt.YAxis)            painter.setTransform(transform)            # 缩放图片高度            width = self.image1.width() / 2            height = int(self.image1.height() *                         (1 - abs(self._angle / self.Scale) / 100))            image = self.image1.scaled(                self.image1.width(), height,                Qt.IgnoreAspectRatio, Qt.SmoothTransformation)            painter.drawPixmap(                QPointF(-width, -height / 2), image)            painter.restore()        else:            # 当翻转角度在90范围内显示第二张图，且从小图缩放到原图的过程            painter.save()            if self._angle &gt; 0:                angle = 180 + self._angle            else:                angle = self._angle - 180            # 设置翻转角度， 注意这里角度有差异            transform.rotate(angle, Qt.YAxis)            painter.setTransform(transform)            # 缩放图片高度            width = self.image2.width() / 2            height = int(self.image2.height() *                         (1 - ((360 - abs(angle)) / self.Scale / 100)))            image = self.image2.scaled(                self.image2.width(), height,                Qt.IgnoreAspectRatio, Qt.SmoothTransformation)            painter.drawPixmap(                QPointF(-width, -height / 2), image)            painter.restore()</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/PyQt5/PyQt/blob/master/QPropertyAnimation/FlipWidgetAnimation.py" target="_blank" rel="noopener">https://github.com/PyQt5/PyQt/blob/master/QPropertyAnimation/FlipWidgetAnimation.py</a></p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://github.com/PyQt5/PyQt/raw/master/QPropertyAnimation/ScreenShot/FlipWidgetAnimation.gif" alt="FlipWidgetAnimation"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QQ的界面一直是用来模仿练习做界面的好东西，这里就有一个类似QQ登录界面的实现翻转效果，当然这里并没有用两个窗口去做，而是用了&lt;code&gt;QStackedWidget&lt;/code&gt;包含两个控件做切换，同时单独使用一个窗口做动画绘制。&lt;br&gt;
    
    </summary>
    
      <category term="例子" scheme="https://pyqt5.com/categories/%E4%BE%8B%E5%AD%90/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="动画" scheme="https://pyqt5.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="翻转" scheme="https://pyqt5.com/tags/%E7%BF%BB%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>PyQt属性动画(QPropertyAnimation)</title>
    <link href="https://pyqt5.com/QPropertyAnimation.html"/>
    <id>https://pyqt5.com/QPropertyAnimation.html</id>
    <published>2019-05-08T07:43:06.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p><code>QPropertyAnimation</code>继承自<code>QVariantAnimation</code>，其作为Qt的属性动画用于针对控件的属性或者继承自<code>QObject</code>的对象中定义的属性做修改，<br>简单来说就是基类是<code>QObject</code>且定义了属性变量，就可以用<code>QPropertyAnimation</code>来做属性动画。同时也可以通过<code>pyqtProperty</code>来增加自定义属性。<br><a id="more"></a></p><p>首先，通过构造函数<code>QPropertyAnimation(QObject, Union[QByteArray, bytes, bytearray], parent: QObject = None)</code>创建一个对象，其中</p><ol><li>第一个参数是动画作用的对象，也可以通过<code>setTargetObject</code>设置</li><li>第二个参数是属性名，在py3中类型是bytes，也可以通过<code>setPropertyName</code>设置</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>一些常见的设置函数</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">setPropertyName</td><td style="text-align:left">设置属性名</td></tr><tr><td style="text-align:left">setTargetObject</td><td style="text-align:left">设置动画作用对象</td></tr><tr><td style="text-align:left">setDuration</td><td style="text-align:left">设置动画持续时间（毫秒）</td></tr><tr><td style="text-align:left">setStartValue</td><td style="text-align:left">设置开始值</td></tr><tr><td style="text-align:left">setEndValue</td><td style="text-align:left">设置结束值</td></tr><tr><td style="text-align:left">setEasingCurve</td><td style="text-align:left">设置动画曲线</td></tr><tr><td style="text-align:left">setKeyValueAt</td><td style="text-align:left">插入线性值</td></tr><tr><td style="text-align:left">setLoopCount</td><td style="text-align:left">设置循环次数（-1为永久）</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>比如这个例子：</p><ol><li>修改控件的<code>geometry</code>大小</li><li>修改自定义属性</li><li>修改进度条的value值</li></ol><p><img src="/images/QPropertyAnimation.gif" alt="QPropertyAnimation"></p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on 2019年5月8日@author: Irony@site: https://pyqt5.com https://github.com/892768447@email: 892768447@qq.com@file: @description: &quot;&quot;&quot;from PyQt5.QtCore import QPropertyAnimation, QRect, pyqtProperty, QEasingCurvefrom PyQt5.QtWidgets import QWidget, QPushButton, QVBoxLayout,\    QLabel, QProgressBar, QSpacerItem, QSizePolicy__Author__ = &#39;Irony&#39;__Copyright__ = &#39;Copyright (c) 2019 Irony&#39;__Version__ = 1.0class Window(QWidget):    def __init__(self, *args, **kwargs):        super(Window, self).__init__(*args, **kwargs)        self.resize(400, 400)        self._value = 0        self.button = QPushButton(&#39;属性动画测试&#39;, self)        self.button.clicked.connect(self.doStart)        self.button.setGeometry(0, 0, 80, 40)        self.buttonc = QPushButton(&#39;自定义属性 测试&#39;, self)        self.buttonc.clicked.connect(self.doStartCustom)        self.label = QLabel(&#39;&#39;, self)        self.progressbar = QProgressBar(self)        self.progressbar.setRange(0, 99)        layout = QVBoxLayout(self)        layout.addItem(QSpacerItem(            20, 60, QSizePolicy.Fixed, QSizePolicy.Fixed))        layout.addWidget(self.buttonc)        layout.addWidget(self.label)        layout.addWidget(self.progressbar)        # 进度条动画        self.progressStart()    # 此处是自定义属性，并通过动画修改后，设置QLabel的值    @pyqtProperty(int)    def value(self):        return self._value    @value.setter    def value(self, v):        self._value = v        self.label.setText(&#39;当前值：{}&#39;.format(v))    def doStart(self):        # 第一个参数是要执行的对象        animation = QPropertyAnimation(self.button, b&#39;geometry&#39;, self)        animation.setDuration(2000)  # 持续时间        # 缓和曲线风格,加了曲线动画会很大程度影响        animation.setEasingCurve(QEasingCurve.OutBounce)        animation.setStartValue(QRect(0, 0, 40, 40))        animation.setEndValue(QRect(250, 250, 80, 80))        animation.start(animation.DeleteWhenStopped)    def doStartCustom(self):        # 自定义属性动画        # 由于定义的属性是在继承的QWidget, 所以第一个参数是self        # 第二个参数就是 value        animation = QPropertyAnimation(self, b&#39;value&#39;, self)        animation.setDuration(2000)  # 持续时间        animation.setStartValue(0)        animation.setEndValue(100)        animation.start(animation.DeleteWhenStopped)    def progressStart(self):        # 进度条动画        # 这里 value是QProgressBar自带的属性，具体可以看文档        # https://doc.qt.io/qt-5/qprogressbar.html#properties        animation = QPropertyAnimation(self.progressbar, b&#39;value&#39;, self)        animation.setDuration(2000)  # 持续时间        animation.setLoopCount(-1)        # 这里采用插入线性值,第一个参数的范围是（0-1）        # 第二个参数的范围是进度（最小值-最大值）        animation.setKeyValueAt(0, self.progressbar.minimum())        animation.setKeyValueAt(0.1, 10)        animation.setKeyValueAt(0.2, 30)        animation.setKeyValueAt(0.5, 60)        animation.setKeyValueAt(0.7, 80)        animation.setKeyValueAt(1, self.progressbar.maximum())        animation.start(animation.DeleteWhenStopped)if __name__ == &#39;__main__&#39;:    import sys    from PyQt5.QtWidgets import QApplication    app = QApplication(sys.argv)    w = Window()    w.show()    sys.exit(app.exec_())</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;QPropertyAnimation&lt;/code&gt;继承自&lt;code&gt;QVariantAnimation&lt;/code&gt;，其作为Qt的属性动画用于针对控件的属性或者继承自&lt;code&gt;QObject&lt;/code&gt;的对象中定义的属性做修改，&lt;br&gt;简单来说就是基类是&lt;code&gt;QObject&lt;/code&gt;且定义了属性变量，就可以用&lt;code&gt;QPropertyAnimation&lt;/code&gt;来做属性动画。同时也可以通过&lt;code&gt;pyqtProperty&lt;/code&gt;来增加自定义属性。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://pyqt5.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="动画" scheme="https://pyqt5.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>如何查阅Qt文档</title>
    <link href="https://pyqt5.com/viewapi.html"/>
    <id>https://pyqt5.com/viewapi.html</id>
    <published>2019-05-04T12:50:20.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>很多网友在问有没有PyQt5的文档之类的问题，在PyQt4的时候PyQt官网有了英文版的文档，随后有网友翻译成了中文。不过现在PyQt5官方的文档都指向了C++的Qt文档，其实C++的Qt API文档结构很清晰，翻阅很容易的，需要注意几点。<br><a id="more"></a></p><p>作为一个开发人员确实需要具备查阅文档、查询资料等基础技能，会为自己的开发带来很大的帮助，要善于搜索，通过不同的方式去搜索才能找到自己需要的东西。</p><p>拿Qt C++文档来说，官网地址是：<a href="https://doc.qt.io/qt-5/qtwidgets-module.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qtwidgets-module.html</a> 这里面记录了所有控件的详细函数文档。</p><p>比如拿 输入框 <code>QLineEdit</code> 来说，怎么去查询它的用法和信号槽等资料？</p><p><a href="https://doc.qt.io/qt-5/qlineedit.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qlineedit.html</a></p><h2 id="左侧目录"><a href="#左侧目录" class="headerlink" title="左侧目录"></a>左侧目录</h2><p>在文档左侧目录中有如下几个：</p><p>Properties - 控件里的属性（比如宽高等,通常需要当作函数调用）</p><p>Public Slots - 这个是控件自己的槽函数（当作普通函数就行）</p><p>Signals - 这个是输入框的包含的信号</p><p>Public Functions、Reimplemented Public Functions、Static Public Members、Protected Functions、Reimplemented Protected Functions - 这几个都是函数列表</p><p><img src="/images/howtoviewapi1.png" alt="howtoviewapi1"></p><h2 id="类说明"><a href="#类说明" class="headerlink" title="类说明"></a>类说明</h2><p><img src="/images/howtoviewapi2.png" alt="howtoviewapi2"></p><p>这里有两个注意点</p><ol><li>红色方框内的表示该控件（输入框）继承于<code>QWidget</code>，所以该控件（输入框）拥有父类的所有方法和信号，当当前文档找不到相关资料和函数时，可以去父类找找看。</li><li>紫色方框内表示列举所有的方法（包括父类）</li></ol><h2 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h2><p><img src="/images/howtoviewapi3.png" alt="howtoviewapi3"></p><p>这里列举的就是该控件（输入框）的函数，同理点击上面的紫色方框是查看所有方法，一般这里主要用来查询你需要的功能函数，Qt的函数名比较容易理解，比如：只读ReadOnly，选择文字：setSelection。</p><p>所以再查下这部分资料的时候建议在浏览器中Ctrl + F打开浏览器的搜索框，并输入英文关键词来检索你所需要的函数在哪里。</p><p><img src="/images/howtoviewapi8.png" alt="howtoviewapi8"></p><h2 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h2><p><img src="/images/howtoviewapi4.png" alt="howtoviewapi4"></p><p>这部分列举的是槽函数，其实在PyQt中槽函数可以当作普通的函数。普通的函数也可以作为槽函数，直接通过信号连接即可，注意方框所示，还有很多函数是在父类里面。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><img src="/images/howtoviewapi5.png" alt="howtoviewapi5"></p><p>这部分列举了该控件（输入框）所定义的信号，主要还是看名字，大多都能知道是做什么的，比如：</p><ol><li>editingFinished - 编辑完成信号</li><li>returnPressed - 回车键信号</li><li>textChanged(const QString &amp;text) - 内容改变信号</li></ol><p>这里还有个问题就是参数问题，一般&amp;后面的text作为参数传递到槽函数中</p><h2 id="函数详细说明"><a href="#函数详细说明" class="headerlink" title="函数详细说明"></a>函数详细说明</h2><p>当不明确这个函数是做什么的，可以点击该函数跳转到下面的说明，比如回车键信号<code>returnPressed</code></p><p><img src="/images/howtoviewapi6.png" alt="howtoviewapi6"></p><p>如图上所示，用翻译插件翻译，大部分就明白了，如下：</p><p><img src="/images/howtoviewapi7.png" alt="howtoviewapi7"></p><h2 id="关于如何搜索资料"><a href="#关于如何搜索资料" class="headerlink" title="关于如何搜索资料"></a>关于如何搜索资料</h2><p>比如当你要搜索输入框内容改变事件，一般建议两种搜索，且搜索的时候用空格把关键词分开搜索，而且直接用控件名</p><ol><li>中文搜索引擎：QLineEdit 内容 改变</li><li>英文搜索引擎：QLineEdit text change</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多网友在问有没有PyQt5的文档之类的问题，在PyQt4的时候PyQt官网有了英文版的文档，随后有网友翻译成了中文。不过现在PyQt5官方的文档都指向了C++的Qt文档，其实C++的Qt API文档结构很清晰，翻阅很容易的，需要注意几点。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://pyqt5.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
  </entry>
  
  <entry>
    <title>推荐编辑器LiClipse</title>
    <link href="https://pyqt5.com/suggesteditor.html"/>
    <id>https://pyqt5.com/suggesteditor.html</id>
    <published>2019-05-04T10:04:08.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>关于Python的开发编辑器有很多，每个人有每个人的喜好，经常看到很多在问什么编辑器好用，有人推荐Sublime，有人推荐Pycharm等等，这里就不去比较其它编辑器的优缺点了，只谈谈关于LiClipse这个编辑器在初级使用阶段的智能提示功能等。开箱即用，支持多种语言，RST，Markdown和HTML编辑器的HTML预览。<br><a id="more"></a></p><p>其实LiClipse这个编辑器就是以前的PyDev插件的独立版本，基于Eclipse编辑器开发，去掉了Java的相关开发功能，关于软件的详细说明可以去官网查看： <a href="http://www.liclipse.com/" target="_blank" rel="noopener">http://www.liclipse.com/</a></p><p>编辑器只需要少量的配置，打开即可使用，快速自动import，也可以根据需要安装自己所需的插件，比如json、svn、主题插件等。个人推荐：适合刚入门的新手使用</p><p>由于新版的PyQt和PyDev去掉了详细的函数提示，所以PyQt的智能提示只有函数和返回值，并没有英文注释，但是以前的比如PyQt4的智能提示应该是有详细的英文注释提示。</p><h2 id="界面预览"><a href="#界面预览" class="headerlink" title="界面预览"></a>界面预览</h2><ol><li>主界面<br><img src="/images/editor1.png" alt="editor1"></li><li>鼠标悬停提示<br><img src="/images/editor2.png" alt="editor2"></li><li>输入提示<br><img src="/images/editor3.png" alt="editor3"></li><li>Git面板<br><img src="/images/editor4.png" alt="editor4"></li><li>全局搜索（Ctrl + H）<br><img src="/images/editor5.png" alt="editor5"><br><img src="/images/editor6.png" alt="editor6"></li></ol><h2 id="自动导包"><a href="#自动导包" class="headerlink" title="自动导包"></a>自动导包</h2><p>其实这个功能我是非常喜欢的，通过按下快捷键即可自动寻找包名导入，快捷键 Ctrl + Shift + O</p><p><img src="/images/editor_import.png" alt="editor_import"></p><p>也可以在标红的代码上按下 Ctrl + F1进行导入</p><p><img src="/images/editor_import2.png" alt="editor_import2"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开编辑器后首先要配置【Window -&gt; Preferences】的就是Python的环境变量，可以同时添加多个Python版本</p><p><img src="/images/editor_env.png" alt="editor_env"></p><h2 id="Tab等设置"><a href="#Tab等设置" class="headerlink" title="Tab等设置"></a>Tab等设置</h2><ol><li>Insert spaces for tabs        tab转空格</li><li>Show line numbers             显示行号</li></ol><p><img src="/images/editor_tab.png" alt="editor_tab"></p><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>这个功能可以快速插入自己定义好的模版代码，比如 <code>if __name__ == &#39;__main__&#39;:</code>等等，比如我这里配置的创建文件的模版</p><p><img src="/images/editor_tpl.png" alt="editor_tpl"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">格式化对齐</td><td style="text-align:center">Ctrl + Shift + F</td></tr><tr><td style="text-align:center">自动导包</td><td style="text-align:center">Ctrl + Shift + O</td></tr><tr><td style="text-align:center">快捷提示</td><td style="text-align:center">Alt + /</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Python的开发编辑器有很多，每个人有每个人的喜好，经常看到很多在问什么编辑器好用，有人推荐Sublime，有人推荐Pycharm等等，这里就不去比较其它编辑器的优缺点了，只谈谈关于LiClipse这个编辑器在初级使用阶段的智能提示功能等。开箱即用，支持多种语言，RST，Markdown和HTML编辑器的HTML预览。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://pyqt5.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="编辑器" scheme="https://pyqt5.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>三种方式绑定信号槽</title>
    <link href="https://pyqt5.com/bindsignals.html"/>
    <id>https://pyqt5.com/bindsignals.html</id>
    <published>2019-05-04T08:07:06.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于PyQt5的信号绑定使用的教程比较上，很多还是以前的绑定方式，导致在PyQt5中无法使用，这里归纳总结下已有的几种绑定信号槽的方式，<br>这几种方式各有各的优点和缺点。<br><a id="more"></a></p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>这个方式是最开始接触设计师的时候知道的，主要是通过控件的<code>objectName</code>和<code>QtCore.QMetaObject.connectSlotsByName(Form)</code>提供的连接函数来自动完成注册，<br>比如带有按钮的界面ui文件转成py文件后会发现如下代码：</p><pre><code class="python">self.pushButton = QtWidgets.QPushButton(Form)self.pushButton.setGeometry(QtCore.QRect(60, 40, 93, 28))self.pushButton.setObjectName(&quot;pushButton&quot;)# 通过这里自动完成连接信号槽QtCore.QMetaObject.connectSlotsByName(Form)</code></pre><p>此时只需要继承该UI文件类然后增加如下方法：</p><pre><code class="python">@pyqtSlot()def on_pushButton_clicked(self):    print(&#39;button clicked&#39;)</code></pre><p>这里解释一下，<code>@pyqtSlot()</code>装饰器把函数<code>on_pushButton_clicked</code>包装为一个槽函数，<br>而<code>QtCore.QMetaObject.connectSlotsByName(Form)</code>这句代码的意思就是自动去寻找满足的槽函数</p><p><font color="red">注意：这里有个规范（on_xxxx_clicked）</font>，这里必须要满足<code>on_控件的objectName_控件的信号</code>这样下划线连接起来的函数名才能被识别，<br>比如按钮的点击：<code>on_pushButton_clicked</code>、勾选框的选中：<code>on_checkbox_toggled(self, checked)</code></p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>这种方式则直接通过代码里调用控件的信号的<code>connect</code>方法来进行绑定，比如：</p><pre><code class="python"># 按钮点击函数def doClicked(self):    print(self.sender(), &#39;clicked&#39;)# 绑定点击信号self.pushButton.clicked.connect(self.doClicked)</code></pre><p><font color="red">注意：<code>connect</code>的是函数名字</font>，<code>self.sender()</code>这句代码是获取信号发送者（比如这里就是得到这个按钮对象），<br>用处在于有时候要循环创建一堆按钮</p><h2 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h2><p>通过参数这种方式其实比较特殊，在PyQt中大部分存在，但是在PySide中则很少，原因是两者的封装方式不同。</p><p>同时该方式用于在纯代码中比较常见，而且需要对该控件有那些信号可以用要很熟习，比如：</p><pre><code class="python"># 按钮点击函数def doClicked(self):    print(self.sender(), &#39;clicked&#39;)pushButton = QPushButton(&#39;按钮&#39;, self, clicked=self.doClicked, minimumHeight=40)</code></pre><p>这里可以通过参数（信号名字） = 函数来绑定信号</p><p>同时也可以设置其它参数，比如<br><code>button.setMinimumHeight(40)</code>也可以像参数里那样设置<code>minimumHeight=40</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上关于PyQt5的信号绑定使用的教程比较上，很多还是以前的绑定方式，导致在PyQt5中无法使用，这里归纳总结下已有的几种绑定信号槽的方式，&lt;br&gt;这几种方式各有各的优点和缺点。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="信号" scheme="https://pyqt5.com/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>python 拷贝虚拟环境(一) 　</title>
    <link href="https://pyqt5.com/virtualenvpy.html"/>
    <id>https://pyqt5.com/virtualenvpy.html</id>
    <published>2019-05-02T07:21:01.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>通常来说 ,  刚开始使用python的时候都是把包装到全局路径 , 随着各个项目安装的包越来越多 , 之后每开始一个项目 , pycharm创建索引的时间都越来越漫长 , 所以不可避免得开始使用虚拟环境。<br>经过一番了解 ，虚拟环境的优点有这些：</p><ul><li>改善 pycharm 索引时间;</li><li>各个项目的库不会冲突；</li><li>理论上虚拟环境可以给同版本的操作系统使用(未试验过);</li><li>pip freeze &gt; requestment.txt 导出的依赖清晰;</li><li>各个版本的python共存;</li><li>…<a id="more"></a></li></ul><p>python虚拟环境库除了自带的venv , 还有三方库<code>virtualenv</code> , 此外 在<code>virtualenv</code>基础上又开发了<code>virtualenvwrapper(virtualenvwrapper_win)</code> 来管理</p><p>本文基于<code>virtualenvwrapper</code> 创建的虚拟环境来讲解.</p><pre><code>以下是收集的一些virtualenvwrapper配置教程:# linux平台https://www.cnblogs.com/netfoxman/p/5994697.html# window平台https://blog.csdn.net/shaququ/article/details/54292043  　https://blog.csdn.net/iaau0908/article/details/54021518</code></pre><p>虚拟环境创建多了我们就会发现 ,<br>有时候使用相同版本的环境,一些常用的库是需要重新安装的,<br>那么能不能创建一个基础环境, 默认拥有这些库, 然后在这个基础环境上继续安装三方库呢 ?</p><p>本文经过试验发现是可行的:</p><ol><li><p>创建基础虚拟环境 <code>mkvirtualenv &lt;环境名称&gt; [-p空格python其他版本的解释器路径]</code>.  例如 <code>mkvirtualenv py34 -p c:\Python34\python.exe</code></p></li><li><p>切换到虚拟环境<code>workon py34</code> , 然后安装一下三方库, 然后复制<code>py34</code>这个文件夹备份一下 ;</p></li><li>接着复制这个<code>py34</code>文件夹, 把复制后的文件夹改名为我们需要需要的文件夹例如<code>new34</code></li><li>进入<code>new34文件夹</code>, 用任意编辑器全路径搜索<code>py34</code>(替换虚拟环境的路径)</li><li>删除<code>new34/Scripts</code>下的<code>pip.exe, pip3.exe, pip3.x.exe, easy_install.exe</code>(因为安装路径硬编码到这里面了, 改不了, 需要重新安装)</li><li><a href="https://blog.csdn.net/douniwan007009/article/details/81463958" target="_blank" rel="noopener">https://blog.csdn.net/douniwan007009/article/details/81463958</a> 按方式二 , 源码安装 <code>setuptools</code> 后再用<code>easy_install pip</code> 安装pip后 , 完成 ;<br>如果有问题, 就继续按照方式一的源码安装pip;</li><li>在<code>new34</code>环境下 用<code>pip show 三方库</code> 来看一些库的位置, 确保正确.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常来说 ,  刚开始使用python的时候都是把包装到全局路径 , 随着各个项目安装的包越来越多 , 之后每开始一个项目 , pycharm创建索引的时间都越来越漫长 , 所以不可避免得开始使用虚拟环境。&lt;br&gt;经过一番了解 ，虚拟环境的优点有这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;改善 pycharm 索引时间;&lt;/li&gt;
&lt;li&gt;各个项目的库不会冲突；&lt;/li&gt;
&lt;li&gt;理论上虚拟环境可以给同版本的操作系统使用(未试验过);&lt;/li&gt;
&lt;li&gt;pip freeze &amp;gt; requestment.txt 导出的依赖清晰;&lt;/li&gt;
&lt;li&gt;各个版本的python共存;&lt;/li&gt;
&lt;li&gt;…
    
    </summary>
    
      <category term="随笔" scheme="https://pyqt5.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Python" scheme="https://pyqt5.com/tags/Python/"/>
    
      <category term="virtualenvwrapper" scheme="https://pyqt5.com/tags/virtualenvwrapper/"/>
    
      <category term="virtualenv" scheme="https://pyqt5.com/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>QRunnable线程池发信号</title>
    <link href="https://pyqt5.com/runnablesignal.html"/>
    <id>https://pyqt5.com/runnablesignal.html</id>
    <published>2019-04-30T07:58:09.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>因为只有继承<code>QObject</code>的类才能有信号和自定义信号，而<code>QRunnable</code>并不是继承自<code>QObject</code>，也不能用多继承的方式，这里考虑定义个全局的QObject变量用来存放一些定义好的可复用的信号。<br><a id="more"></a></p><p>pools 是 <code>QThreadPool</code> 实例</p><h2 id="看图说话"><a href="#看图说话" class="headerlink" title="看图说话"></a>看图说话</h2><ol><li><img src="/images/runnablesignal1.png" alt="runnablesignal1"></li><li>定义一个全局信号类<br><img src="/images/runnablesignal2.png" alt="runnablesignal2"></li><li>在QRunnable 中发送<br><img src="/images/runnablesignal3.png" alt="runnablesignal3"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为只有继承&lt;code&gt;QObject&lt;/code&gt;的类才能有信号和自定义信号，而&lt;code&gt;QRunnable&lt;/code&gt;并不是继承自&lt;code&gt;QObject&lt;/code&gt;，也不能用多继承的方式，这里考虑定义个全局的QObject变量用来存放一些定义好的可复用的信号。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="信号" scheme="https://pyqt5.com/tags/%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="线程" scheme="https://pyqt5.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何和设计师中查看ui转换的py代码</title>
    <link href="https://pyqt5.com/viewpyindesigner.html"/>
    <id>https://pyqt5.com/viewpyindesigner.html</id>
    <published>2019-04-30T05:11:09.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>通过 设计师  查看ui转换的py代码</p><p>当初我刚学pyqt的时候 , 也有很多疑惑 , 用什么属性把控件加到布局 , 改了这个属性会发生什么 , 为什么这个会这样, 那个会那样 。。。 。。。</p><p>后来就看ui 转成的py代码 , 注释一下 , 什么效果消失了 , 就是那个api引起的 。<br><a id="more"></a></p><p>再来后发现了官方文档 , 查一查函数就行了 .</p><p>但是有些api文档找起来麻烦 , 用设计师点几下就行了 , 然后把转换出来的代码拷贝一下就完事了.</p><p>可是需要单独把ui转为py文件 , 之后再删除这个文件也是很烦的一件事 .</p><p>好 , 话不多说 , 接下来手把手教你如何快速在ui中查看py代码 .</p><p>官方也考虑过这种情况 , 所以 设计师中 是有这个功能的 , 但是qt的是没问题的 , pyqt的毕竟是绑定过来的 , 所以正常来说 你点击之后会弹出一个找不到应用程序的提示 .</p><p>看到这个东西是不是很眼熟 , 我们用的命令pyuic5 和这个东西应该是一样的 .</p><p><img src="/images/viewpyindesigner1.jpg" alt="viewpyindesigner1"></p><p>所以接下来 , 我们找找电脑上有没有这个东西</p><p><img src="/images/viewpyindesigner2.jpg" alt="viewpyindesigner2"></p><p>果然在pyqt5-toos文件夹下有这个东西 ,</p><p>我们根据第一张图的提示 , 把这个东西拷贝到相应的目录 (如果没有那个bin文件夹, 手动创建),</p><p><img src="/images/viewpyindesigner3.jpg" alt="viewpyindesigner3"></p><p>好了 , 大功告成 !</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 设计师  查看ui转换的py代码&lt;/p&gt;
&lt;p&gt;当初我刚学pyqt的时候 , 也有很多疑惑 , 用什么属性把控件加到布局 , 改了这个属性会发生什么 , 为什么这个会这样, 那个会那样 。。。 。。。&lt;/p&gt;
&lt;p&gt;后来就看ui 转成的py代码 , 注释一下 , 什么效果消失了 , 就是那个api引起的 。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="Designer" scheme="https://pyqt5.com/tags/Designer/"/>
    
      <category term="设计师" scheme="https://pyqt5.com/tags/%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5调整窗口显示边框</title>
    <link href="https://pyqt5.com/showframe.html"/>
    <id>https://pyqt5.com/showframe.html</id>
    <published>2019-04-26T14:19:26.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>windows</code>某些场景下调整窗口大小或者移动后就会导致里面的内容重绘（速度慢，卡顿，闪烁），其实在以前<code>windows</code>在低配置设备为了减少这种频繁绘制的情况，默认会开启这种效果，不过目前设备越来越好了就关闭了该功能。具体是在控制面板中-&gt;调整<code>Windows</code>的外观和性能-&gt;去掉勾选 拖动时显示窗口内容。<br><a id="more"></a></p><p>由于这个开关是全局状态的，而我们只需要在自己的窗口中实现该效果有两种方式。</p><ol><li>一种是自己绘制一个边框效果，放开鼠标时才操作真正的窗口。</li><li>二是替换窗口的处理过程函数<code>wndproc</code>处理<code>WM_NCLBUTTONDOWN</code>消息事件。</li></ol><p>今天讲第二种方法：</p><ol><li>需要了解 <code>SystemParametersInfo</code> API函数</li><li><code>SPI_GETDRAGFULLWINDOWS</code>：确定是否允许拖拉到最大窗口</li><li><code>SPI_SETDRAGFULLWINDOWS</code>：设置是否允许拖至最大窗口</li></ol><p>效果就是这样的：</p><p><img src="https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/ShowFrameWhenDrag.gif" alt="ShowFrameWhenDrag"></p><p>正如图片所看的那样，窗体在移动的时候，窗体并没有绘制出来，而是绘制出窗体的边框，等到窗体不在移动的时候就直接把窗体图像数据全部绘制出来，这样就避免了窗体在移动的时候出现闪烁的现象。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/PyQt5/PyQt/blob/master/Demo/ShowFrameWhenDrag.py" target="_blank" rel="noopener">https://github.com/PyQt5/PyQt/blob/master/Demo/ShowFrameWhenDrag.py</a></p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on 2019年4月23日@author: Irony@site: https://pyqt5.com https://github.com/892768447@email: 892768447@qq.com@file: ShowFrameWhenDrag@description: 调整窗口显示边框&quot;&quot;&quot;from ctypes import sizeof, windll, c_int, byref, c_long, c_void_p, c_ulong, c_longlong,\    c_ulonglong, WINFUNCTYPE, c_uintfrom PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel__Author__ = &#39;Irony&#39;__Copyright__ = &#39;Copyright (c) 2019 Irony&#39;__Version__ = 1.0if sizeof(c_long) == sizeof(c_void_p):    WPARAM = c_ulong    LPARAM = c_longelif sizeof(c_longlong) == sizeof(c_void_p):    WPARAM = c_ulonglong    LPARAM = c_longlongWM_NCLBUTTONDOWN = 0x00a1GWL_WNDPROC = -4SPI_GETDRAGFULLWINDOWS = 38SPI_SETDRAGFULLWINDOWS = 37WNDPROC = WINFUNCTYPE(c_long, c_void_p, c_uint, WPARAM, LPARAM)try:    CallWindowProc = windll.user32.CallWindowProcW    SetWindowLong = windll.user32.SetWindowLongW    SystemParametersInfo = windll.user32.SystemParametersInfoWexcept:    CallWindowProc = windll.user32.CallWindowProcA    SetWindowLong = windll.user32.SetWindowLongA    SystemParametersInfo = windll.user32.SystemParametersInfoAdef GetDragFullwindows():    rv = c_int()    SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, byref(rv), 0)    return rv.valuedef SetDragFullwindows(value):    SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, value, 0, 0)class Window(QWidget):    def __init__(self, *args, **kwargs):        super(Window, self).__init__(*args, **kwargs)        layout = QVBoxLayout(self)        layout.addWidget(QLabel(&#39;拖动或者调整窗口试试看&#39;))        # 重点替换窗口处理过程        self._newwndproc = WNDPROC(self._wndproc)        self._oldwndproc = SetWindowLong(            int(self.winId()), GWL_WNDPROC, self._newwndproc)    def _wndproc(self, hwnd, msg, wparam, lparam):        if msg == WM_NCLBUTTONDOWN:            # 获取系统本身是否已经开启            isDragFullWindow = GetDragFullwindows()            if isDragFullWindow != 0:                # 开启虚线框                SetDragFullwindows(0)                # 系统本身处理                ret = CallWindowProc(                    self._oldwndproc, hwnd, msg, wparam, lparam)                # 关闭虚线框                SetDragFullwindows(1)                return ret        return CallWindowProc(self._oldwndproc, hwnd, msg, wparam, lparam)if __name__ == &#39;__main__&#39;:    import sys    from PyQt5.QtWidgets import QApplication    app = QApplication(sys.argv)    w = Window()    w.show()    sys.exit(app.exec_())</code></pre><h2 id="片尾"><a href="#片尾" class="headerlink" title="片尾"></a>片尾</h2><p>替换窗口过程可以处理很多系统窗口的处理过程，更多需要读者自行去发现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;某些场景下调整窗口大小或者移动后就会导致里面的内容重绘（速度慢，卡顿，闪烁），其实在以前&lt;code&gt;windows&lt;/code&gt;在低配置设备为了减少这种频繁绘制的情况，默认会开启这种效果，不过目前设备越来越好了就关闭了该功能。具体是在控制面板中-&amp;gt;调整&lt;code&gt;Windows&lt;/code&gt;的外观和性能-&amp;gt;去掉勾选 拖动时显示窗口内容。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="边框" scheme="https://pyqt5.com/tags/%E8%BE%B9%E6%A1%86/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5判断信号是否连接</title>
    <link href="https://pyqt5.com/issignalconnected.html"/>
    <id>https://pyqt5.com/issignalconnected.html</id>
    <published>2019-04-26T14:06:26.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>PyQt</code>中某些情况下需要取消原来的信号连接，此时需要使用<code>disconnect</code>方法，但是在逻辑不严谨的情况下可能会导致多次调用<code>disconnect</code>方法而导致报错，当然可以通过try except来包裹代码。这里通过 <code>isSignalConnected</code> 来判断信号是否连接。<br><a id="more"></a></p><p>在QOjbect文档中这样写到：</p><pre><code class="c++">static const QMetaMethod valueChangedSignal = QMetaMethod::fromSignal(&amp;MyObject::valueChanged);if (isSignalConnected(valueChangedSignal)) {    QByteArray data;    data = get_the_value();       // expensive operation    emit valueChanged(data);}</code></pre><p>通过直接传入信号就行了，但是这在PyQt中不可行。需要这么做</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on 2019年2月24日@author: Irony@site: https://pyqt5.com https://github.com/892768447@email: 892768447@qq.com@file: IsSignalConnected@description: 判断信号是否连接&quot;&quot;&quot;from PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QTextBrowser__Author__ = &quot;&quot;&quot;By: IronyQQ: 892768447Email: 892768447@qq.com&quot;&quot;&quot;__Copyright__ = &#39;Copyright (c) 2019 Irony&#39;__Version__ = 1.0class Window(QWidget):    def __init__(self, *args, **kwargs):        super(Window, self).__init__(*args, **kwargs)        layout = QVBoxLayout(self)        self.button1 = QPushButton(&#39;已连接&#39;, self, clicked=self.doTest)        self.button2 = QPushButton(&#39;未连接&#39;, self)        self.retView = QTextBrowser(self)        layout.addWidget(self.button1)        layout.addWidget(self.button2)        layout.addWidget(self.retView)    def doTest(self):        self.retView.append(&quot;&quot;&quot;        # button1 clicked 是否连接: %s        # button2 clicked 是否连接: %s        &quot;&quot;&quot; % (            self.isSignalConnected(self.button1, &#39;clicked()&#39;),            self.isSignalConnected(self.button2, &#39;clicked()&#39;)        ))    def isSignalConnected(self, obj, name):        &quot;&quot;&quot;判断信号是否连接        :param obj:        对象        :param name:       信号名，如 clicked()        &quot;&quot;&quot;        index = obj.metaObject().indexOfMethod(name)        if index &gt; -1:            method = obj.metaObject().method(index)            if method:                return obj.isSignalConnected(method)        return Falseif __name__ == &#39;__main__&#39;:    import sys    from PyQt5.QtWidgets import QApplication    app = QApplication(sys.argv)    w = Window()    w.show()    sys.exit(app.exec_())</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/IsSignalConnected.png" alt="IsSignalConnected"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;PyQt&lt;/code&gt;中某些情况下需要取消原来的信号连接，此时需要使用&lt;code&gt;disconnect&lt;/code&gt;方法，但是在逻辑不严谨的情况下可能会导致多次调用&lt;code&gt;disconnect&lt;/code&gt;方法而导致报错，当然可以通过try except来包裹代码。这里通过 &lt;code&gt;isSignalConnected&lt;/code&gt; 来判断信号是否连接。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="信号" scheme="https://pyqt5.com/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5无边框圆角阴影</title>
    <link href="https://pyqt5.com/shadowradius.html"/>
    <id>https://pyqt5.com/shadowradius.html</id>
    <published>2019-04-25T16:06:26.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>在做PyQt窗口开发中经常会遇到要做一些无边框不规则的窗口，可能还会带有阴影效果，这里演示做一个简单的无边框圆角的窗口，原理就在于背景窗口的透明和一层有色背景控件的叠加。<br><a id="more"></a></p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><ol><li>黑色（方便说明）的<code>QDialog</code>或者<code>QWidget</code>作为全透明无边框窗口。</li><li>其中白色的<code>QWidget</code>才是主要显示圆角和阴影的窗口，用于承载其它控件的显示。</li><li>注意红色和紫色的方框内的层次。</li><li>另：如果要熟悉纯代码编写请看 <a href="https://github.com/PyQt5/PyQt/blob/master/Demo/FramelessDialog.py" target="_blank" rel="noopener">FramelessDialog.py</a></li></ol><p>如图：</p><p><img src="https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/FramelessDialog1.png" alt="FramelessDialog1"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/PyQt5/PyQt/blob/master/Demo/FramelessDialog.py" target="_blank" rel="noopener">https://github.com/PyQt5/PyQt/blob/master/Demo/FramelessDialog.py</a></p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on 2019年4月25日@author: Irony@site: https://pyqt5.com https://github.com/892768447@email: 892768447@qq.com@file: FramelessWidget@description: 无边框圆角带阴影窗口 &quot;&quot;&quot;from PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QDialog, QGraphicsDropShadowEffectfrom frameless import Ui_Dialog__Author__ = &#39;Irony&#39;__Copyright__ = &#39;Copyright (c) 2019&#39;class Window(QDialog, Ui_Dialog):    def __init__(self, *args, **kwargs):        super(Window, self).__init__(*args, **kwargs)        self.mPos = None        self.setupUi(self)        self.closeButton.clicked.connect(self.close)        # 重点        # 无边框        self.setWindowFlags(self.windowFlags() | Qt.FramelessWindowHint)        # 背景透明（就是ui中黑色背景的那个控件）        self.setAttribute(Qt.WA_TranslucentBackground, True)        # 添加阴影        effect = QGraphicsDropShadowEffect(self)        effect.setBlurRadius(12)        effect.setOffset(0, 0)        effect.setColor(Qt.gray)        self.setGraphicsEffect(effect)    # 加上简单的移动功能    def mousePressEvent(self, event):        &quot;&quot;&quot;鼠标点击事件&quot;&quot;&quot;        if event.button() == Qt.LeftButton:            self.mPos = event.pos()        event.accept()    def mouseReleaseEvent(self, event):        &#39;&#39;&#39;鼠标弹起事件&#39;&#39;&#39;        self.mPos = None        event.accept()    def mouseMoveEvent(self, event):        if event.buttons() == Qt.LeftButton and self.mPos:            self.move(self.mapToGlobal(event.pos() - self.mPos))        event.accept()if __name__ == &#39;__main__&#39;:    import sys    from PyQt5.QtWidgets import QApplication    app = QApplication(sys.argv)    w = Window()    w.show()    sys.exit(app.exec_())</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/FramelessDialog.png" alt="FramelessDialog"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="/files/无边框圆角阴影.zip">无边框圆角阴影.zip</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做PyQt窗口开发中经常会遇到要做一些无边框不规则的窗口，可能还会带有阴影效果，这里演示做一个简单的无边框圆角的窗口，原理就在于背景窗口的透明和一层有色背景控件的叠加。&lt;br&gt;
    
    </summary>
    
      <category term="例子" scheme="https://pyqt5.com/categories/%E4%BE%8B%E5%AD%90/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
      <category term="阴影" scheme="https://pyqt5.com/tags/%E9%98%B4%E5%BD%B1/"/>
    
      <category term="无边框" scheme="https://pyqt5.com/tags/%E6%97%A0%E8%BE%B9%E6%A1%86/"/>
    
      <category term="圆角" scheme="https://pyqt5.com/tags/%E5%9C%86%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>解决GitHub下载速度缓慢的问题</title>
    <link href="https://pyqt5.com/speedgithub.html"/>
    <id>https://pyqt5.com/speedgithub.html</id>
    <published>2019-04-18T00:59:06.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>由于Github的下载走的是AWS - 亚马逊的路线，，so slow，跟乌龟一样慢。。照着一些方法改了hosts文件，偶尔能提提速度。<br><a id="more"></a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>Hosts文件的路径是：</p><p>C:\Windows\System32\drivers\etc</p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>终端内输入：</p><p>sudo vim /etc/hosts</p><h2 id="追加域名的IP地址"><a href="#追加域名的IP地址" class="headerlink" title="追加域名的IP地址"></a>追加域名的IP地址</h2><p>利用<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 来获得以下两个GitHub域名的IP地址：</p><p>(1) github.com</p><p>(2) github.global.ssl.fastly.net</p><p>打开网页后，利用输入框内分别查询两个域名</p><p>将以上两段IP写入Hosts文件中：</p><pre><code>192.30.253.112               github.com151.101.185.194              github.global.ssl.fastly.net</code></pre><p>保存。</p><p>刷新 DNS 缓存</p><p>在终端或CMD中，执行以下命令：</p><p>ipconfig /flushdns</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于Github的下载走的是AWS - 亚马逊的路线，，so slow，跟乌龟一样慢。。照着一些方法改了hosts文件，偶尔能提提速度。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://pyqt5.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Github" scheme="https://pyqt5.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>在Mac上以正确的姿势使用PyQtClient看Demo</title>
    <link href="https://pyqt5.com/pyqtclientmac.html"/>
    <id>https://pyqt5.com/pyqtclientmac.html</id>
    <published>2019-04-02T09:18:43.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>由于PyQtClient只提供了Windows的版本，这里记录下编译后在Mac上运行。<br><a id="more"></a></p><h2 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h2><p>安装git略。没有的东西可以都先去试试brew install xxx。没安装homebrew的建议使用搜索引擎</p><p><code>git clone https://github.com/PyQt5/PyQtClient.git</code></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ol><li>打开IDE配置python环境，使用anaconda比较方便</li><li>推荐用pycharm，我是习惯了用idea。anaconda安装可以去官网下载。</li><li>环境原因，选择新建一个 python 3.6 p.s. 我取的环境名字就是 3.6 所以后面的3.6其实是这个原因</li></ol><h2 id="conda源"><a href="#conda源" class="headerlink" title="conda源"></a>conda源</h2><p>最好是加环境变量，不加也可以，就是以后用到的都需要指定路径，不太常用，我就没加</p><pre><code>~/anaconda3/bin/conda config --add channels conda-forge~/anaconda3/bin/conda config --add channels defaults~/anaconda3/bin/conda config --add channels r~/anaconda3/bin/conda config --add channels bioconda~/anaconda3/bin/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ </code></pre><h2 id="pip源"><a href="#pip源" class="headerlink" title="pip源"></a>pip源</h2><pre><code>mkdir ~/.pip &amp;&amp; vim ~/.pip/pip.conf</code></pre><pre><code>[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com</code></pre><h2 id="安装编译依赖"><a href="#安装编译依赖" class="headerlink" title="安装编译依赖"></a>安装编译依赖</h2><pre><code>~/.conda/envs/3.6/bin/pip install -r PyQtClient/requirements.txt</code></pre><p>运行提示没有webkit，开始手动编译</p><ol><li><code>wget http://download.qt.io/archive/qt/5.9/5.9.0/qt-opensource-mac-x64-5.9.0.dmg</code></li><li><code>wget https://github.com/annulen/webkit/releases/download/qtwebkit-5.212.0-alpha2/qtwebkit-5.212.0_alpha2-qt59-darwin-x64.tar.xz</code></li><li><code>wget https://www.riverbankcomputing.com/static/Downloads/PyQt5/5.10.1/PyQt5_gpl-5.10.1.zip</code></li><li><code>wget https://www.riverbankcomputing.com/static/Downloads/sip/4.19.8/sip-4.19.8.tar.gz</code></li><li>编译sip：<code>~/.conda/envs/3.6/bin/python configure.py --platform macx-g++ &amp;&amp; make &amp;&amp; sudo make install</code></li><li>编译Webkit.so 没有qmake 和 sip的环境变量， 所以后面都是手动指定的<pre><code>~/.conda/envs/3.6/bin/python configure.py --confirm-license --no-designer-plugin --no-qml-plugin --disable=dbus --disable=QAxContainer --disable=QtAndroidExtras --disable=QtBluetooth --disable=QtDBus --disable=QtDesigner --disable=Enginio --disable=QtLocation --disable=QtMacExtras --disable=QtMultimedia --disable=QtMultimediaWidgets --disable=QtNfc --disable=QtSerialPort --disable=QtSql --disable=QtSvg --disable=QtTest --disable=QtWinExtras --disable=QtX11Extras --disable=QtXml --disable=QtXmlPatterns --disable=pylupdate --disable=pyrcc --qmake=~/Qt5.9.0/5.9/clang_64/bin/qmake --sip=~/.conda/3.6/bin/sip &amp;&amp; make &amp;&amp; sudo make install</code></pre></li></ol><h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><ol><li>libcurl版本要求10.0，而我的是9.0，原因是前面我自己摸索，乱装依赖，所以遇到了<pre><code>~/anaconda3/bin/conda install -n 3.6 -c conda-forge libcurl</code></pre></li><li>结果这个libcurl 10.0.0 是装上了，可是pygit2版本不对了，conda给升级了，PyQtClient里requirements.txt要求这个包的版本（pygit2==0.27.2）几乎决定了其他的环境版本。后来还是老实的用conda去装了。这个连python版本什么的都会跟着变的。最后降级的结果是python 3.6.7<pre><code>~/anaconda3/bin/conda install -n 3.6 -c conda-forge libgit2==0.27.2</code></pre></li></ol><p>至此总算是启动正常了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于PyQtClient只提供了Windows的版本，这里记录下编译后在Mac上运行。&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="PyQt" scheme="https://pyqt5.com/tags/PyQt/"/>
    
  </entry>
  
  <entry>
    <title>Python调用Java对Excel截图</title>
    <link href="https://pyqt5.com/calljava.html"/>
    <id>https://pyqt5.com/calljava.html</id>
    <published>2019-03-12T13:15:06.000Z</published>
    <updated>2019-12-26T12:14:56.491Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候会遇到一些奇葩的需求，就是用Excel做报表，但是需要对里面的数据进行填充并生成报表图片，发送出去。这里记录用python调用jar包对excel文件进行公式计算和截图，数据填充可以用xlrd或者openpyxl<br><a id="more"></a></p><p>利用<code>jpype</code>模块初始化java虚拟机加载jar包然后执行其中的功能。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on 2019年3月12日@author: Irony@site: https://pyqt5.com https://github.com/892768447@email: 892768447@qq.com@file: CallJava@description: &quot;&quot;&quot;import osimport jpype__Author__ = &#39;Irony&#39;__Copyright__ = &#39;Copyright (c) 2019&#39;def convertToImage():    Workbook = jpype.JClass(&#39;com.aspose.cells.Workbook&#39;)    ImageFormat = jpype.JClass(&#39;com.aspose.cells.ImageFormat&#39;)    ImageOrPrintOptions = jpype.JClass(        &#39;com.aspose.cells.ImageOrPrintOptions&#39;)    SheetRender = jpype.JClass(&#39;com.aspose.cells.SheetRender&#39;)    book = Workbook(os.path.abspath(&#39;data/test.xlsx&#39;).replace(&#39;\\&#39;, &#39;/&#39;))    # 保存为html    book.save(&#39;data/index.html&#39;, 12)    # 保存为pdf    book.save(&#39;data/test.pdf&#39;)    # 截图    imgOptions = ImageOrPrintOptions()    # imgOptions.setQuality(100)    imgOptions.setOnePagePerSheet(True)    # 输出图片格式#     imgOptions.setImageFormat(ImageFormat.getJpeg())    imgOptions.setImageFormat(ImageFormat.getPng())    # 计算    CalculationOptions = jpype.JClass(        &#39;com.aspose.cells.CalculationOptions&#39;)    opt = CalculationOptions()    # 对Sheet1中的公式进行计算    sheet = book.getWorksheets().get(&#39;Sheet1&#39;)    sheet.calculateFormula(opt, True)    # 设置区域    pageSetup = sheet.getPageSetup()    # 去掉边距    pageSetup.setBottomMargin(0.)    pageSetup.setLeftMargin(0.)    pageSetup.setRightMargin(0.)    pageSetup.setTopMargin(0.)    # 设置要截图的区域(对角线)    pageSetup.setPrintArea(&#39;A0:C2&#39;)    # Create a SheetRender object for the target sheet    sr = SheetRender(sheet, imgOptions)    for page in range(sr.getPageCount()):        # Generate an image for the worksheet        sr.toImage(            page, os.path.join(&#39;data&#39;, &#39;%d.png&#39; % (page + 1)))def test():    # emm这里不知道什么用绝对路径就报错    libs = &#39;{};{}&#39;.format(        &#39;libs/bcprov-jdk16-146.jar&#39;,        &#39;libs/aspose-cells-19.2.jar&#39;    )    command = (jpype.getDefaultJVMPath(),                   &#39;-ea&#39;, &#39;-Xmn128m&#39;, &#39;-Xms512M&#39;, &#39;-Xmx512M&#39;,                   &#39;-Djava.class.path={0}&#39;.format(libs))    print(command)    jpype.startJVM(jpype.getDefaultJVMPath(),                   &#39;-ea&#39;, &#39;-Xmn128m&#39;, &#39;-Xms512M&#39;, &#39;-Xmx512M&#39;,                   &#39;-Djava.class.path={0}&#39;.format(libs)                   )    # 解决多线程问题    jpype.attachThreadToJVM()    # 对excel截图    convertToImage()    # 关闭虚拟机    jpype.shutdownJVM()    print(&#39;截图完成&#39;)if __name__ == &#39;__main__&#39;:    test()</code></pre><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="/files/调用java生成报表.7z">调用java生成报表.7z</a></p><p>解压后进入whls文件夹安装对应版本的jpype包</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/images/calljava.png" alt="calljava"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候会遇到一些奇葩的需求，就是用Excel做报表，但是需要对里面的数据进行填充并生成报表图片，发送出去。这里记录用python调用jar包对excel文件进行公式计算和截图，数据填充可以用xlrd或者openpyxl&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="https://pyqt5.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="https://pyqt5.com/tags/Python/"/>
    
      <category term="截图" scheme="https://pyqt5.com/tags/%E6%88%AA%E5%9B%BE/"/>
    
  </entry>
  
</feed>
