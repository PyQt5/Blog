{"author":"不许人间见白头","title":"python 在类里使用进程池","slug":"processinclass","date":"2018-11-16 21:37:31","updated":"2019-12-26T11:54:14.175Z","comments":true,"path":"api/articles/processinclass.json","url":"https://pyqt5.com/processinclass.html","excerpt":"首先， 进程池的作用就是减少进程的创建和释放 开销的， 所以在类中作为局部变量是不合适的; 其次， 进程池必须在if __name__ == &quot;__main__&quot;里 ，否则会报 frozen_ 什么什么的错误;（这一点可能解释有误）;","covers":["/images/processinclass1.png","/images/processinclass2.png"],"content":"<ol>\n<li>首先， 进程池的作用就是减少进程的创建和释放 开销的， 所以在类中作为局部变量是不合适的; </li>\n<li><p>其次， 进程池必须在<code>if __name__ == &quot;__main__&quot;</code>里 ，否则会报 frozen_ 什么什么的错误;（这一点可能解释有误）;</p>\n<a id=\"more\"></a>\n</li>\n<li><p>然后， 线程池的<code>apply_async</code>中如果传入<code>self.xxx</code>方法，会报<code>multiprocessing.Pool pickling error</code>什么的错误， 具体解释见<a href=\"https://blog.csdn.net/dutsoft/article/details/70336462，\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dutsoft/article/details/70336462，</a> 里面有解决方法，但是我没有成功（最开始测试没有现在理解的透彻， 不过应该是可以的）; 由于第1点 不合理， 所以有什么办法在类 函数中获取 进程池对象po的地址： </p>\n</li>\n</ol>\n<p><img src=\"/images/processinclass1.png\" alt=\"processinclass1\"></p>\n<p>我的解决思路和方法是: </p>\n<ol>\n<li>通过globals() 取得全局变量 ， 测试证明 ：不同文件的<code>globals()</code>是不同的： 如<code>Tab2.py</code>的 <code>globals()</code> 和<code>main_extra_func_file.py</code>中的 <code>globals()</code>是不同的 ， 所以 这样在<code>Tab2.py</code>中取不到po对象； </li>\n<li>通过<code>__main__.po</code> 来获取 （为什么会想到这个呢， 因为有时候导包 import .xxx 和import xxx 会报 <code>__main__</code> 没有什么属性什么的）：</li>\n</ol>\n<pre><code class=\"python\">def getPoolObject():\n# po 的名字在main函数中定义\n# __main__ 模块在sys.modules 的键是&quot;__mp_main__&quot;\n    return sys.modules[&quot;__mp_main__&quot;].po\n</code></pre>\n<p>ps : (图没截好 ， <code>rglob_worker</code> 是外部函数 ， 非类内函数 ，po = getPoolBojcet() 这一行是类内函数 ，红色箭头 2. 在的那条白色分割线 是2个函数。 ) </p>\n<p><img src=\"/images/processinclass2.png\" alt=\"processinclass2\"></p>\n<p><code>len(po._cache) == 1</code> : po._cache 是当前有任务的进程数， ==1表示所有任务结束; 利用回调 ， 可以更轻松地进行进程通信。</p>\n","raw":"---\nauthor: 不许人间见白头\ntitle: python 在类里使用进程池\ndate: 2018-11-16 21:37:31\ntop: 1\ntags: \n - 进程\ncategories: 笔记\n---\n\n1. 首先， 进程池的作用就是减少进程的创建和释放 开销的， 所以在类中作为局部变量是不合适的; \n2. 其次， 进程池必须在`if __name__ == \"__main__\" `里 ，否则会报 frozen_ 什么什么的错误;（这一点可能解释有误）;\n<!-- more -->\n\n3. 然后， 线程池的`apply_async`中如果传入`self.xxx`方法，会报`multiprocessing.Pool pickling error`什么的错误， 具体解释见https://blog.csdn.net/dutsoft/article/details/70336462， 里面有解决方法，但是我没有成功（最开始测试没有现在理解的透彻， 不过应该是可以的）; 由于第1点 不合理， 所以有什么办法在类 函数中获取 进程池对象po的地址： \n\n![processinclass1](/images/processinclass1.png)\n\n我的解决思路和方法是: \n1. 通过globals() 取得全局变量 ， 测试证明 ：不同文件的`globals()`是不同的： 如`Tab2.py `的 `globals()` 和` main_extra_func_file.py`中的 `globals() `是不同的 ， 所以 这样在`Tab2.py`中取不到po对象； \n2. 通过`__main__.po` 来获取 （为什么会想到这个呢， 因为有时候导包 import .xxx 和import xxx 会报 `__main__` 没有什么属性什么的）：\n\n```python\ndef getPoolObject():\n# po 的名字在main函数中定义\n# __main__ 模块在sys.modules 的键是\"__mp_main__\"\n    return sys.modules[\"__mp_main__\"].po\n```\n\nps : (图没截好 ， `rglob_worker` 是外部函数 ， 非类内函数 ，po = getPoolBojcet() 这一行是类内函数 ，红色箭头 2. 在的那条白色分割线 是2个函数。 ) \n\n![processinclass2](/images/processinclass2.png)\n\n`len(po._cache) == 1` : po._cache 是当前有任务的进程数， ==1表示所有任务结束; 利用回调 ， 可以更轻松地进行进程通信。","categories":[{"name":"笔记","path":"api/categories/笔记.json"}],"tags":[{"name":"进程","path":"api/tags/进程.json"}]}