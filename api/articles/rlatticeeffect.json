{"author":"Irony","title":"PyQt5仿网页鼠标移动点阵特效","slug":"rlatticeeffect","date":"2018-10-29 16:49:10","updated":"2019-12-26T12:14:56.491Z","comments":true,"path":"api/articles/rlatticeeffect.json","url":"https://pyqt5.com/rlatticeeffect.html","excerpt":"Orz，前段时间有个zz需求，就是要做一个类似网页上很多个多点连线、鼠标移动跟随的那种炫酷特效，然后花了点时间在网上找了js做的，刚开始打算是嵌入QWebView来显示网页，后来研究了下js的算法代码，遂改用QWidget的paintEvent直接绘制。<br>","covers":["https://github.com/PyQt5/PyQt/raw/master/QPropertyAnimation/ScreenShot/RlatticeEffect.gif"],"content":"<p>Orz，前段时间有个zz需求，就是要做一个类似网页上很多个多点连线、鼠标移动跟随的那种炫酷特效，然后花了点时间在网上找了js做的，刚开始打算是嵌入<code>QWebView</code>来显示网页，后来研究了下js的算法代码，遂改用<code>QWidget</code>的<code>paintEvent</code>直接绘制。<br><a id=\"more\"></a></p>\n<h2 id=\"大概思路\"><a href=\"#大概思路\" class=\"headerlink\" title=\"大概思路\"></a>大概思路</h2><ol>\n<li>先根据窗口大小随机创建一些点</li>\n<li>遍历这些点并找到与之相关联的点</li>\n<li>在动画过程中绘制圆点和画两点之间的连线</li>\n<li>属性动画<code>QPropertyAnimation</code>改变颜色的透明度</li>\n</ol>\n<h2 id=\"题外\"><a href=\"#题外\" class=\"headerlink\" title=\"题外\"></a>题外</h2><ol>\n<li>这里没有仔细去研究js里的算法优化,在浏览器里嗖嗖的就生成了,在py里好慢….</li>\n<li>尽量在py里优化了循环操作,也简单的做了个cython加速也才提高了1s ? 1倍?…</li>\n<li>不要只是为了好看用这玩意儿,和网页的效果一样,占CPU !!!!!!没有任何意义</li>\n<li>如果有更好的优化算法请告知, 3Q</li>\n<li>pyd是python3.4生成的,删掉pyd也能运行</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><a href=\"https://github.com/PyQt5/PyQt/blob/master/QPropertyAnimation/RlatticeEffect.py\" target=\"_blank\" rel=\"noopener\">https://github.com/PyQt5/PyQt/blob/master/QPropertyAnimation/RlatticeEffect.py</a></p>\n<pre><code class=\"python\">#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n&quot;&quot;&quot;\nCreated on 2018年11月22日\n@author: Irony\n@site: https://pyqt5.com, https://github.com/892768447\n@email: 892768447@qq.com\n@file: \n@description: \n&quot;&quot;&quot;\nfrom random import random\nfrom time import time\n\nfrom PyQt5.QtCore import QPropertyAnimation, QObject, pyqtProperty, QEasingCurve,\\\n    Qt, QRectF, pyqtSignal\nfrom PyQt5.QtGui import QColor, QPainterPath, QPainter\nfrom PyQt5.QtWidgets import QWidget\n\n\n__Author__ = &quot;&quot;&quot;By: Irony\nQQ: 892768447\nEmail: 892768447@qq.com&quot;&quot;&quot;\n__Copyright__ = &#39;Copyright (c) 2018 Irony&#39;\n__Version__ = 1.0\n\n\ntry:\n    import pointtool  # @UnusedImport @UnresolvedImport\n    getDistance = pointtool.getDistance\n    findClose = pointtool.findClose\nexcept:\n    import math\n\n    def getDistance(p1, p2):\n        return math.pow(p1.x - p2.x, 2) + math.pow(p1.y - p2.y, 2)\n\n    def findClose(points):\n        plen = len(points)\n        for i in range(plen):\n            closest = [None, None, None, None, None]\n            p1 = points[i]\n            for j in range(plen):\n                p2 = points[j]\n                dte1 = getDistance(p1, p2)\n                if p1 != p2:\n                    placed = False\n                    for k in range(5):\n                        if not placed:\n                            if not closest[k]:\n                                closest[k] = p2\n                                placed = True\n                    for k in range(5):\n                        if not placed:\n                            if dte1 &lt; getDistance(p1, closest[k]):\n                                closest[k] = p2\n                                placed = True\n            p1.closest = closest\n\n\nclass Target:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Point(QObject):\n\n    valueChanged = pyqtSignal()\n\n    def __init__(self, x, ox, y, oy, *args, **kwargs):\n        super(Point, self).__init__(*args, **kwargs)\n        self.__x = x\n        self._x = x\n        self.originX = ox\n        self._y = y\n        self.__y = y\n        self.originY = oy\n        # 5个闭合点\n        self.closest = [0, 0, 0, 0, 0]\n        # 圆半径\n        self.radius = 2 + random() * 2\n        # 连线颜色\n        self.lineColor = QColor(156, 217, 249)\n        # 圆颜色\n        self.circleColor = QColor(156, 217, 249)\n\n    def initAnimation(self):\n        # 属性动画\n        if not hasattr(self, &#39;xanimation&#39;):\n            self.xanimation = QPropertyAnimation(\n                self, b&#39;x&#39;, self, valueChanged=self.valueChanged.emit,\n                easingCurve=QEasingCurve.InOutSine)\n            self.yanimation = QPropertyAnimation(\n                self, b&#39;y&#39;, self, valueChanged=self.valueChanged.emit,\n                easingCurve=QEasingCurve.InOutSine,\n                finished=self.updateAnimation)\n            self.updateAnimation()\n\n    def updateAnimation(self):\n        self.xanimation.stop()\n        self.yanimation.stop()\n        duration = (1 + random()) * 1000\n        self.xanimation.setDuration(duration)\n        self.yanimation.setDuration(duration)\n        self.xanimation.setStartValue(self.__x)\n        self.xanimation.setEndValue(self.originX - 50 + random() * 100)\n        self.yanimation.setStartValue(self.__y)\n        self.yanimation.setEndValue(self.originY - 50 + random() * 100)\n        self.xanimation.start()\n        self.yanimation.start()\n\n    @pyqtProperty(float)\n    def x(self):\n        return self._x\n\n    @x.setter\n    def x(self, x):\n        self._x = x\n\n    @pyqtProperty(float)\n    def y(self):\n        return self._y\n\n    @y.setter\n    def y(self, y):\n        self._y = y\n\n\nclass Window(QWidget):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n        self.setMouseTracking(True)\n        self.resize(800, 600)\n        self.points = []\n        self.target = Target(self.width() / 2, self.height() / 2)\n        self.initPoints()\n\n    def paintEvent(self, event):\n        super(Window, self).paintEvent(event)\n        painter = QPainter()\n        painter.begin(self)\n        painter.setRenderHint(QPainter.Antialiasing)\n        painter.fillRect(self.rect(), Qt.black)\n        self.animate(painter)\n        painter.end()\n\n    def mouseMoveEvent(self, event):\n        super(Window, self).mouseMoveEvent(event)\n        # 鼠标移动时更新xy坐标\n        self.target.x = event.x()\n        self.target.y = event.y()\n        self.update()\n\n    def initPoints(self):\n        t = time()\n        self.points.clear()\n        # 创建点\n        stepX = self.width() / 20\n        stepY = self.height() / 20\n        for x in range(0, self.width(), int(stepX)):\n            for y in range(0, self.height(), int(stepY)):\n                ox = x + random() * stepX\n                oy = y + random() * stepY\n                point = Point(ox, ox, oy, oy)\n                point.valueChanged.connect(self.update)\n                self.points.append(point)\n        print(time() - t)\n\n        t = time()\n        # 每个点寻找5个闭合点\n        findClose(self.points)\n        print(time() - t)\n\n    def animate(self, painter):\n        for p in self.points:\n            # 检测点的范围\n            value = abs(getDistance(self.target, p))\n            if value &lt; 4000:\n                # 其实就是修改颜色透明度\n                p.lineColor.setAlphaF(0.3)\n                p.circleColor.setAlphaF(0.6)\n            elif value &lt; 20000:\n                p.lineColor.setAlphaF(0.1)\n                p.circleColor.setAlphaF(0.3)\n            elif value &lt; 40000:\n                p.lineColor.setAlphaF(0.02)\n                p.circleColor.setAlphaF(0.1)\n            else:\n                p.lineColor.setAlphaF(0)\n                p.circleColor.setAlphaF(0)\n\n            # 画线条\n            if p.lineColor.alpha():\n                for pc in p.closest:\n                    if not pc:\n                        continue\n                    path = QPainterPath()\n                    path.moveTo(p.x, p.y)\n                    path.lineTo(pc.x, pc.y)\n                    painter.save()\n                    painter.setPen(p.lineColor)\n                    painter.drawPath(path)\n                    painter.restore()\n\n            # 画圆\n            painter.save()\n            painter.setPen(Qt.NoPen)\n            painter.setBrush(p.circleColor)\n            painter.drawRoundedRect(QRectF(\n                p.x - p.radius, p.y - p.radius, 2 * p.radius, 2 * p.radius), p.radius, p.radius)\n            painter.restore()\n\n            # 开启动画\n            p.initAnimation()\n\n\nif __name__ == &#39;__main__&#39;:\n    import sys\n    import cgitb\n    sys.excepthook = cgitb.enable(1, None, 5, &#39;&#39;)\n    from PyQt5.QtWidgets import QApplication\n    app = QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_())\n</code></pre>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"https://github.com/PyQt5/PyQt/raw/master/QPropertyAnimation/ScreenShot/RlatticeEffect.gif\" alt=\"RlatticeEffect\"></p>\n","raw":"---\nauthor: Irony\ntitle: PyQt5仿网页鼠标移动点阵特效\ndate: 2018-10-29 16:49:10\ntop: 1\ntags: \n - PyQt\n - 动画\n - 特效\ncategories: 例子\n---\n\nOrz，前段时间有个zz需求，就是要做一个类似网页上很多个多点连线、鼠标移动跟随的那种炫酷特效，然后花了点时间在网上找了js做的，刚开始打算是嵌入`QWebView`来显示网页，后来研究了下js的算法代码，遂改用`QWidget`的`paintEvent`直接绘制。\n<!-- more -->\n\n## 大概思路\n\n1. 先根据窗口大小随机创建一些点\n2. 遍历这些点并找到与之相关联的点\n3. 在动画过程中绘制圆点和画两点之间的连线\n4. 属性动画`QPropertyAnimation`改变颜色的透明度\n\n## 题外\n\n1. 这里没有仔细去研究js里的算法优化,在浏览器里嗖嗖的就生成了,在py里好慢....\n2. 尽量在py里优化了循环操作,也简单的做了个cython加速也才提高了1s ? 1倍?...\n3. 不要只是为了好看用这玩意儿,和网页的效果一样,占CPU !!!!!!没有任何意义\n4. 如果有更好的优化算法请告知, 3Q\n5. pyd是python3.4生成的,删掉pyd也能运行\n\n## 代码\n\nhttps://github.com/PyQt5/PyQt/blob/master/QPropertyAnimation/RlatticeEffect.py\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nCreated on 2018年11月22日\n@author: Irony\n@site: https://pyqt5.com, https://github.com/892768447\n@email: 892768447@qq.com\n@file: \n@description: \n\"\"\"\nfrom random import random\nfrom time import time\n\nfrom PyQt5.QtCore import QPropertyAnimation, QObject, pyqtProperty, QEasingCurve,\\\n    Qt, QRectF, pyqtSignal\nfrom PyQt5.QtGui import QColor, QPainterPath, QPainter\nfrom PyQt5.QtWidgets import QWidget\n\n\n__Author__ = \"\"\"By: Irony\nQQ: 892768447\nEmail: 892768447@qq.com\"\"\"\n__Copyright__ = 'Copyright (c) 2018 Irony'\n__Version__ = 1.0\n\n\ntry:\n    import pointtool  # @UnusedImport @UnresolvedImport\n    getDistance = pointtool.getDistance\n    findClose = pointtool.findClose\nexcept:\n    import math\n\n    def getDistance(p1, p2):\n        return math.pow(p1.x - p2.x, 2) + math.pow(p1.y - p2.y, 2)\n\n    def findClose(points):\n        plen = len(points)\n        for i in range(plen):\n            closest = [None, None, None, None, None]\n            p1 = points[i]\n            for j in range(plen):\n                p2 = points[j]\n                dte1 = getDistance(p1, p2)\n                if p1 != p2:\n                    placed = False\n                    for k in range(5):\n                        if not placed:\n                            if not closest[k]:\n                                closest[k] = p2\n                                placed = True\n                    for k in range(5):\n                        if not placed:\n                            if dte1 < getDistance(p1, closest[k]):\n                                closest[k] = p2\n                                placed = True\n            p1.closest = closest\n\n\nclass Target:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Point(QObject):\n\n    valueChanged = pyqtSignal()\n\n    def __init__(self, x, ox, y, oy, *args, **kwargs):\n        super(Point, self).__init__(*args, **kwargs)\n        self.__x = x\n        self._x = x\n        self.originX = ox\n        self._y = y\n        self.__y = y\n        self.originY = oy\n        # 5个闭合点\n        self.closest = [0, 0, 0, 0, 0]\n        # 圆半径\n        self.radius = 2 + random() * 2\n        # 连线颜色\n        self.lineColor = QColor(156, 217, 249)\n        # 圆颜色\n        self.circleColor = QColor(156, 217, 249)\n\n    def initAnimation(self):\n        # 属性动画\n        if not hasattr(self, 'xanimation'):\n            self.xanimation = QPropertyAnimation(\n                self, b'x', self, valueChanged=self.valueChanged.emit,\n                easingCurve=QEasingCurve.InOutSine)\n            self.yanimation = QPropertyAnimation(\n                self, b'y', self, valueChanged=self.valueChanged.emit,\n                easingCurve=QEasingCurve.InOutSine,\n                finished=self.updateAnimation)\n            self.updateAnimation()\n\n    def updateAnimation(self):\n        self.xanimation.stop()\n        self.yanimation.stop()\n        duration = (1 + random()) * 1000\n        self.xanimation.setDuration(duration)\n        self.yanimation.setDuration(duration)\n        self.xanimation.setStartValue(self.__x)\n        self.xanimation.setEndValue(self.originX - 50 + random() * 100)\n        self.yanimation.setStartValue(self.__y)\n        self.yanimation.setEndValue(self.originY - 50 + random() * 100)\n        self.xanimation.start()\n        self.yanimation.start()\n\n    @pyqtProperty(float)\n    def x(self):\n        return self._x\n\n    @x.setter\n    def x(self, x):\n        self._x = x\n\n    @pyqtProperty(float)\n    def y(self):\n        return self._y\n\n    @y.setter\n    def y(self, y):\n        self._y = y\n\n\nclass Window(QWidget):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n        self.setMouseTracking(True)\n        self.resize(800, 600)\n        self.points = []\n        self.target = Target(self.width() / 2, self.height() / 2)\n        self.initPoints()\n\n    def paintEvent(self, event):\n        super(Window, self).paintEvent(event)\n        painter = QPainter()\n        painter.begin(self)\n        painter.setRenderHint(QPainter.Antialiasing)\n        painter.fillRect(self.rect(), Qt.black)\n        self.animate(painter)\n        painter.end()\n\n    def mouseMoveEvent(self, event):\n        super(Window, self).mouseMoveEvent(event)\n        # 鼠标移动时更新xy坐标\n        self.target.x = event.x()\n        self.target.y = event.y()\n        self.update()\n\n    def initPoints(self):\n        t = time()\n        self.points.clear()\n        # 创建点\n        stepX = self.width() / 20\n        stepY = self.height() / 20\n        for x in range(0, self.width(), int(stepX)):\n            for y in range(0, self.height(), int(stepY)):\n                ox = x + random() * stepX\n                oy = y + random() * stepY\n                point = Point(ox, ox, oy, oy)\n                point.valueChanged.connect(self.update)\n                self.points.append(point)\n        print(time() - t)\n\n        t = time()\n        # 每个点寻找5个闭合点\n        findClose(self.points)\n        print(time() - t)\n\n    def animate(self, painter):\n        for p in self.points:\n            # 检测点的范围\n            value = abs(getDistance(self.target, p))\n            if value < 4000:\n                # 其实就是修改颜色透明度\n                p.lineColor.setAlphaF(0.3)\n                p.circleColor.setAlphaF(0.6)\n            elif value < 20000:\n                p.lineColor.setAlphaF(0.1)\n                p.circleColor.setAlphaF(0.3)\n            elif value < 40000:\n                p.lineColor.setAlphaF(0.02)\n                p.circleColor.setAlphaF(0.1)\n            else:\n                p.lineColor.setAlphaF(0)\n                p.circleColor.setAlphaF(0)\n\n            # 画线条\n            if p.lineColor.alpha():\n                for pc in p.closest:\n                    if not pc:\n                        continue\n                    path = QPainterPath()\n                    path.moveTo(p.x, p.y)\n                    path.lineTo(pc.x, pc.y)\n                    painter.save()\n                    painter.setPen(p.lineColor)\n                    painter.drawPath(path)\n                    painter.restore()\n\n            # 画圆\n            painter.save()\n            painter.setPen(Qt.NoPen)\n            painter.setBrush(p.circleColor)\n            painter.drawRoundedRect(QRectF(\n                p.x - p.radius, p.y - p.radius, 2 * p.radius, 2 * p.radius), p.radius, p.radius)\n            painter.restore()\n\n            # 开启动画\n            p.initAnimation()\n\n\nif __name__ == '__main__':\n    import sys\n    import cgitb\n    sys.excepthook = cgitb.enable(1, None, 5, '')\n    from PyQt5.QtWidgets import QApplication\n    app = QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_())\n```\n\n## 效果图\n\n![RlatticeEffect](https://github.com/PyQt5/PyQt/raw/master/QPropertyAnimation/ScreenShot/RlatticeEffect.gif)\n\n","categories":[{"name":"例子","path":"api/categories/例子.json"}],"tags":[{"name":"PyQt","path":"api/tags/PyQt.json"},{"name":"动画","path":"api/tags/动画.json"},{"name":"特效","path":"api/tags/特效.json"}]}