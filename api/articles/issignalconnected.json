{"author":"Irony","title":"PyQt5判断信号是否连接","slug":"issignalconnected","date":"2019-04-26 22:06:26","updated":"2020-02-21T15:24:35.837Z","comments":true,"path":"api/articles/issignalconnected.json","url":"https://pyqt5.com/issignalconnected.html","excerpt":"在PyQt中某些情况下需要取消原来的信号连接，此时需要使用disconnect方法，但是在逻辑不严谨的情况下可能会导致多次调用disconnect方法而导致报错，当然可以通过try except来包裹代码。这里通过 isSignalConnected 来判断信号是否连接。<br>","covers":["https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/IsSignalConnected.png"],"content":"<p>在<code>PyQt</code>中某些情况下需要取消原来的信号连接，此时需要使用<code>disconnect</code>方法，但是在逻辑不严谨的情况下可能会导致多次调用<code>disconnect</code>方法而导致报错，当然可以通过try except来包裹代码。这里通过 <code>isSignalConnected</code> 来判断信号是否连接。<br><a id=\"more\"></a></p>\n<p>在QOjbect文档中这样写到：</p>\n<pre><code class=\"c++\">static const QMetaMethod valueChangedSignal = QMetaMethod::fromSignal(&amp;MyObject::valueChanged);\nif (isSignalConnected(valueChangedSignal)) {\n    QByteArray data;\n    data = get_the_value();       // expensive operation\n    emit valueChanged(data);\n}\n</code></pre>\n<p>通过直接传入信号就行了，但是这在PyQt中不可行。需要这么做</p>\n<pre><code class=\"python\">#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n&quot;&quot;&quot;\nCreated on 2019年2月24日\n@author: Irony\n@site: https://pyqt5.com https://github.com/892768447\n@email: 892768447@qq.com\n@file: IsSignalConnected\n@description: 判断信号是否连接\n&quot;&quot;&quot;\n\nfrom PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QTextBrowser\n\n\n__Author__ = &quot;&quot;&quot;By: Irony\nQQ: 892768447\nEmail: 892768447@qq.com&quot;&quot;&quot;\n__Copyright__ = &#39;Copyright (c) 2019 Irony&#39;\n__Version__ = 1.0\n\n\nclass Window(QWidget):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n        layout = QVBoxLayout(self)\n        self.button1 = QPushButton(&#39;已连接&#39;, self, clicked=self.doTest)\n        self.button2 = QPushButton(&#39;未连接&#39;, self)\n        self.retView = QTextBrowser(self)\n        layout.addWidget(self.button1)\n        layout.addWidget(self.button2)\n        layout.addWidget(self.retView)\n\n    def doTest(self):\n        self.retView.append(&quot;&quot;&quot;\n        # button1 clicked 是否连接: %s\n        # button2 clicked 是否连接: %s\n        &quot;&quot;&quot; % (\n            self.isSignalConnected(self.button1, &#39;clicked()&#39;),\n            self.isSignalConnected(self.button2, &#39;clicked()&#39;)\n        ))\n\n    def isSignalConnected(self, obj, name):\n        &quot;&quot;&quot;判断信号是否连接\n        :param obj:        对象\n        :param name:       信号名，如 clicked()\n        &quot;&quot;&quot;\n        index = obj.metaObject().indexOfMethod(name)\n        if index &gt; -1:\n            method = obj.metaObject().method(index)\n            if method:\n                return obj.isSignalConnected(method)\n        return False\n\n\nif __name__ == &#39;__main__&#39;:\n    import sys\n    from PyQt5.QtWidgets import QApplication\n    app = QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_())\n</code></pre>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/IsSignalConnected.png\" alt=\"IsSignalConnected\"></p>\n","raw":"---\nauthor: Irony\ntitle: PyQt5判断信号是否连接\ndate: 2019-04-26 22:06:26\ntop: 1\ntags: \n - PyQt\n - 信号\ncategories: 教程\n---\n\n在`PyQt`中某些情况下需要取消原来的信号连接，此时需要使用`disconnect`方法，但是在逻辑不严谨的情况下可能会导致多次调用`disconnect`方法而导致报错，当然可以通过try except来包裹代码。这里通过 `isSignalConnected` 来判断信号是否连接。\n<!-- more -->\n\n在QOjbect文档中这样写到：\n\n```c++\nstatic const QMetaMethod valueChangedSignal = QMetaMethod::fromSignal(&MyObject::valueChanged);\nif (isSignalConnected(valueChangedSignal)) {\n    QByteArray data;\n    data = get_the_value();       // expensive operation\n    emit valueChanged(data);\n}\n```\n\n通过直接传入信号就行了，但是这在PyQt中不可行。需要这么做\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nCreated on 2019年2月24日\n@author: Irony\n@site: https://pyqt5.com https://github.com/892768447\n@email: 892768447@qq.com\n@file: IsSignalConnected\n@description: 判断信号是否连接\n\"\"\"\n\nfrom PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QTextBrowser\n\n\n__Author__ = \"\"\"By: Irony\nQQ: 892768447\nEmail: 892768447@qq.com\"\"\"\n__Copyright__ = 'Copyright (c) 2019 Irony'\n__Version__ = 1.0\n\n\nclass Window(QWidget):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n        layout = QVBoxLayout(self)\n        self.button1 = QPushButton('已连接', self, clicked=self.doTest)\n        self.button2 = QPushButton('未连接', self)\n        self.retView = QTextBrowser(self)\n        layout.addWidget(self.button1)\n        layout.addWidget(self.button2)\n        layout.addWidget(self.retView)\n\n    def doTest(self):\n        self.retView.append(\"\"\"\n        # button1 clicked 是否连接: %s\n        # button2 clicked 是否连接: %s\n        \"\"\" % (\n            self.isSignalConnected(self.button1, 'clicked()'),\n            self.isSignalConnected(self.button2, 'clicked()')\n        ))\n\n    def isSignalConnected(self, obj, name):\n        \"\"\"判断信号是否连接\n        :param obj:        对象\n        :param name:       信号名，如 clicked()\n        \"\"\"\n        index = obj.metaObject().indexOfMethod(name)\n        if index > -1:\n            method = obj.metaObject().method(index)\n            if method:\n                return obj.isSignalConnected(method)\n        return False\n\n\nif __name__ == '__main__':\n    import sys\n    from PyQt5.QtWidgets import QApplication\n    app = QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_())\n```\n\n## 效果图\n\n![IsSignalConnected](https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/IsSignalConnected.png)","categories":[{"name":"教程","path":"api/categories/教程.json"}],"tags":[{"name":"PyQt","path":"api/tags/PyQt.json"},{"name":"信号","path":"api/tags/信号.json"}]}