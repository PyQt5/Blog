{"author":"Irony","title":"PyQt5调整窗口显示边框","slug":"showframe","date":"2019-04-26 22:19:26","updated":"2020-02-21T15:20:38.584Z","comments":true,"path":"api/articles/showframe.json","url":"https://pyqt5.com/showframe.html","excerpt":"在windows某些场景下调整窗口大小或者移动后就会导致里面的内容重绘（速度慢，卡顿，闪烁），其实在以前windows在低配置设备为了减少这种频繁绘制的情况，默认会开启这种效果，不过目前设备越来越好了就关闭了该功能。具体是在控制面板中-&gt;调整Windows的外观和性能-&gt;去掉勾选 拖动时显示窗口内容。<br>","covers":["https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/ShowFrameWhenDrag.gif"],"content":"<p>在<code>windows</code>某些场景下调整窗口大小或者移动后就会导致里面的内容重绘（速度慢，卡顿，闪烁），其实在以前<code>windows</code>在低配置设备为了减少这种频繁绘制的情况，默认会开启这种效果，不过目前设备越来越好了就关闭了该功能。具体是在控制面板中-&gt;调整<code>Windows</code>的外观和性能-&gt;去掉勾选 拖动时显示窗口内容。<br><a id=\"more\"></a></p>\n<p>由于这个开关是全局状态的，而我们只需要在自己的窗口中实现该效果有两种方式。</p>\n<ol>\n<li>一种是自己绘制一个边框效果，放开鼠标时才操作真正的窗口。</li>\n<li>二是替换窗口的处理过程函数<code>wndproc</code>处理<code>WM_NCLBUTTONDOWN</code>消息事件。</li>\n</ol>\n<p>今天讲第二种方法：</p>\n<ol>\n<li>需要了解 <code>SystemParametersInfo</code> API函数</li>\n<li><code>SPI_GETDRAGFULLWINDOWS</code>：确定是否允许拖拉到最大窗口</li>\n<li><code>SPI_SETDRAGFULLWINDOWS</code>：设置是否允许拖至最大窗口</li>\n</ol>\n<p>效果就是这样的：</p>\n<p><img src=\"https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/ShowFrameWhenDrag.gif\" alt=\"ShowFrameWhenDrag\"></p>\n<p>正如图片所看的那样，窗体在移动的时候，窗体并没有绘制出来，而是绘制出窗体的边框，等到窗体不在移动的时候就直接把窗体图像数据全部绘制出来，这样就避免了窗体在移动的时候出现闪烁的现象。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><a href=\"https://github.com/PyQt5/PyQt/blob/master/Demo/ShowFrameWhenDrag.py\" target=\"_blank\" rel=\"noopener\">https://github.com/PyQt5/PyQt/blob/master/Demo/ShowFrameWhenDrag.py</a></p>\n<pre><code class=\"python\">#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n&quot;&quot;&quot;\nCreated on 2019年4月23日\n@author: Irony\n@site: https://pyqt5.com https://github.com/892768447\n@email: 892768447@qq.com\n@file: ShowFrameWhenDrag\n@description: 调整窗口显示边框\n&quot;&quot;&quot;\nfrom ctypes import sizeof, windll, c_int, byref, c_long, c_void_p, c_ulong, c_longlong,\\\n    c_ulonglong, WINFUNCTYPE, c_uint\n\nfrom PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel\n\n\n__Author__ = &#39;Irony&#39;\n__Copyright__ = &#39;Copyright (c) 2019 Irony&#39;\n__Version__ = 1.0\n\nif sizeof(c_long) == sizeof(c_void_p):\n    WPARAM = c_ulong\n    LPARAM = c_long\nelif sizeof(c_longlong) == sizeof(c_void_p):\n    WPARAM = c_ulonglong\n    LPARAM = c_longlong\n\nWM_NCLBUTTONDOWN = 0x00a1\nGWL_WNDPROC = -4\nSPI_GETDRAGFULLWINDOWS = 38\nSPI_SETDRAGFULLWINDOWS = 37\nWNDPROC = WINFUNCTYPE(c_long, c_void_p, c_uint, WPARAM, LPARAM)\n\ntry:\n    CallWindowProc = windll.user32.CallWindowProcW\n    SetWindowLong = windll.user32.SetWindowLongW\n    SystemParametersInfo = windll.user32.SystemParametersInfoW\nexcept:\n    CallWindowProc = windll.user32.CallWindowProcA\n    SetWindowLong = windll.user32.SetWindowLongA\n    SystemParametersInfo = windll.user32.SystemParametersInfoA\n\n\ndef GetDragFullwindows():\n    rv = c_int()\n    SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, byref(rv), 0)\n    return rv.value\n\n\ndef SetDragFullwindows(value):\n    SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, value, 0, 0)\n\n\nclass Window(QWidget):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n        layout = QVBoxLayout(self)\n        layout.addWidget(QLabel(&#39;拖动或者调整窗口试试看&#39;))\n\n        # 重点替换窗口处理过程\n        self._newwndproc = WNDPROC(self._wndproc)\n        self._oldwndproc = SetWindowLong(\n            int(self.winId()), GWL_WNDPROC, self._newwndproc)\n\n    def _wndproc(self, hwnd, msg, wparam, lparam):\n        if msg == WM_NCLBUTTONDOWN:\n            # 获取系统本身是否已经开启\n            isDragFullWindow = GetDragFullwindows()\n            if isDragFullWindow != 0:\n                # 开启虚线框\n                SetDragFullwindows(0)\n                # 系统本身处理\n                ret = CallWindowProc(\n                    self._oldwndproc, hwnd, msg, wparam, lparam)\n                # 关闭虚线框\n                SetDragFullwindows(1)\n                return ret\n        return CallWindowProc(self._oldwndproc, hwnd, msg, wparam, lparam)\n\n\nif __name__ == &#39;__main__&#39;:\n    import sys\n    from PyQt5.QtWidgets import QApplication\n    app = QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_())\n</code></pre>\n<h2 id=\"片尾\"><a href=\"#片尾\" class=\"headerlink\" title=\"片尾\"></a>片尾</h2><p>替换窗口过程可以处理很多系统窗口的处理过程，更多需要读者自行去发现。</p>\n","raw":"---\nauthor: Irony\ntitle: PyQt5调整窗口显示边框\ndate: 2019-04-26 22:19:26\ntop: 1\ntags: \n - PyQt\n - 边框\ncategories: 教程\n---\n\n在`windows`某些场景下调整窗口大小或者移动后就会导致里面的内容重绘（速度慢，卡顿，闪烁），其实在以前`windows`在低配置设备为了减少这种频繁绘制的情况，默认会开启这种效果，不过目前设备越来越好了就关闭了该功能。具体是在控制面板中->调整`Windows`的外观和性能->去掉勾选 拖动时显示窗口内容。\n<!-- more -->\n\n由于这个开关是全局状态的，而我们只需要在自己的窗口中实现该效果有两种方式。\n\n1. 一种是自己绘制一个边框效果，放开鼠标时才操作真正的窗口。\n2. 二是替换窗口的处理过程函数`wndproc`处理`WM_NCLBUTTONDOWN`消息事件。\n\n今天讲第二种方法：\n\n1. 需要了解 `SystemParametersInfo` API函数\n2. `SPI_GETDRAGFULLWINDOWS`：确定是否允许拖拉到最大窗口\n3. `SPI_SETDRAGFULLWINDOWS`：设置是否允许拖至最大窗口\n\n效果就是这样的：\n\n![ShowFrameWhenDrag](https://github.com/PyQt5/PyQt/raw/master/Demo/ScreenShot/ShowFrameWhenDrag.gif)\n\n正如图片所看的那样，窗体在移动的时候，窗体并没有绘制出来，而是绘制出窗体的边框，等到窗体不在移动的时候就直接把窗体图像数据全部绘制出来，这样就避免了窗体在移动的时候出现闪烁的现象。\n\n## 代码\n\nhttps://github.com/PyQt5/PyQt/blob/master/Demo/ShowFrameWhenDrag.py\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nCreated on 2019年4月23日\n@author: Irony\n@site: https://pyqt5.com https://github.com/892768447\n@email: 892768447@qq.com\n@file: ShowFrameWhenDrag\n@description: 调整窗口显示边框\n\"\"\"\nfrom ctypes import sizeof, windll, c_int, byref, c_long, c_void_p, c_ulong, c_longlong,\\\n    c_ulonglong, WINFUNCTYPE, c_uint\n\nfrom PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel\n\n\n__Author__ = 'Irony'\n__Copyright__ = 'Copyright (c) 2019 Irony'\n__Version__ = 1.0\n\nif sizeof(c_long) == sizeof(c_void_p):\n    WPARAM = c_ulong\n    LPARAM = c_long\nelif sizeof(c_longlong) == sizeof(c_void_p):\n    WPARAM = c_ulonglong\n    LPARAM = c_longlong\n\nWM_NCLBUTTONDOWN = 0x00a1\nGWL_WNDPROC = -4\nSPI_GETDRAGFULLWINDOWS = 38\nSPI_SETDRAGFULLWINDOWS = 37\nWNDPROC = WINFUNCTYPE(c_long, c_void_p, c_uint, WPARAM, LPARAM)\n\ntry:\n    CallWindowProc = windll.user32.CallWindowProcW\n    SetWindowLong = windll.user32.SetWindowLongW\n    SystemParametersInfo = windll.user32.SystemParametersInfoW\nexcept:\n    CallWindowProc = windll.user32.CallWindowProcA\n    SetWindowLong = windll.user32.SetWindowLongA\n    SystemParametersInfo = windll.user32.SystemParametersInfoA\n\n\ndef GetDragFullwindows():\n    rv = c_int()\n    SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, byref(rv), 0)\n    return rv.value\n\n\ndef SetDragFullwindows(value):\n    SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, value, 0, 0)\n\n\nclass Window(QWidget):\n\n    def __init__(self, *args, **kwargs):\n        super(Window, self).__init__(*args, **kwargs)\n        layout = QVBoxLayout(self)\n        layout.addWidget(QLabel('拖动或者调整窗口试试看'))\n\n        # 重点替换窗口处理过程\n        self._newwndproc = WNDPROC(self._wndproc)\n        self._oldwndproc = SetWindowLong(\n            int(self.winId()), GWL_WNDPROC, self._newwndproc)\n\n    def _wndproc(self, hwnd, msg, wparam, lparam):\n        if msg == WM_NCLBUTTONDOWN:\n            # 获取系统本身是否已经开启\n            isDragFullWindow = GetDragFullwindows()\n            if isDragFullWindow != 0:\n                # 开启虚线框\n                SetDragFullwindows(0)\n                # 系统本身处理\n                ret = CallWindowProc(\n                    self._oldwndproc, hwnd, msg, wparam, lparam)\n                # 关闭虚线框\n                SetDragFullwindows(1)\n                return ret\n        return CallWindowProc(self._oldwndproc, hwnd, msg, wparam, lparam)\n\n\nif __name__ == '__main__':\n    import sys\n    from PyQt5.QtWidgets import QApplication\n    app = QApplication(sys.argv)\n    w = Window()\n    w.show()\n    sys.exit(app.exec_())\n```\n\n## 片尾\n\n替换窗口过程可以处理很多系统窗口的处理过程，更多需要读者自行去发现。","categories":[{"name":"教程","path":"api/categories/教程.json"}],"tags":[{"name":"PyQt","path":"api/tags/PyQt.json"},{"name":"边框","path":"api/tags/边框.json"}]}