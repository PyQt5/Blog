{"author":"人间白头　","title":"python 获取子进程print信息 　","slug":"pyqt_get_subprocess_pipeline","date":"2019-05-24 14:39:44","updated":"2019-10-21T14:49:45.387Z","comments":true,"path":"api/articles/pyqt_get_subprocess_pipeline.json","url":"https://pyqt5.com/pyqt_get_subprocess_pipeline.html","excerpt":"在PyQt中使用子线程读取子进程Python脚本的print输出流内容。","covers":["https://i.loli.net/2019/05/24/5ce793171984f27031.png","https://i.loli.net/2019/05/24/5ce7933994a0090037.png"],"content":"<p>在PyQt中使用子线程读取子进程Python脚本的print输出流内容。</p>\n<a id=\"more\"></a>\n<p>问题所在：</p>\n<p><img src=\"https://i.loli.net/2019/05/24/5ce793171984f27031.png\" alt=\"image.png\"></p>\n<p>如果模块都由自己开发， 正常操作 </p>\n<p><img src=\"https://i.loli.net/2019/05/24/5ce7933994a0090037.png\" alt=\"image.png\"></p>\n<p>但是因为不能改, 所以只能拦截：<br>代码：</p>\n<pre><code class=\"python\">pythonPath = self.pythonPath_cb.currentText()\n\nif suffix == &quot;py&quot;:\n    # 首次\n    self.pyCommand = [pythonPath, path]\n    self.modifiedReloadPython(path)\ndef modifiedReloadPython(self, path_):\n    os.chdir(os.path.dirname(path_))\n    # 子进程调用\n    self.p = subprocess.Popen(self.pyCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    # self.stdoutWorker.p = self.p\n    self.stdoutWorker = Worker(self.p)\n    self.stdoutWorker.stdout_signal.connect(lambda x: self.error_te.append(&quot;PYDEBUG:\\n&quot; + x))\n    self.stdoutWorker.start()\nclass Worker(QThread):\n    stdout_signal = pyqtSignal(str)\n\n    def __init__(self, p, parent=None):\n        super().__init__(parent)\n        self.p = p\n\n    def run(self):\n        while True:\n            QApplication.processEvents()\n            if self.p is not None:\n                line = self.p.stdout.readline()\n                # line = line.strip()\n                if line != b&#39;&#39;:\n                    try:\n                        info = line.decode()\n                        self.stdout_signal.emit(info)\n                    except:\n                        self.stdout_signal.emit(repr(line))\n\n</code></pre>\n","raw":"---\nauthor: 人间白头　\ntitle: python 获取子进程print信息 　\ndate: 2019-05-24 14:39:44\ntop: 1\ntags:\n - Python\n - subprocess.Popen\n - 拦截print\ncategories: 随笔\n---\n\n在PyQt中使用子线程读取子进程Python脚本的print输出流内容。\n\n<!-- more -->\n\n问题所在：\n\n![image.png](https://i.loli.net/2019/05/24/5ce793171984f27031.png)\n\n如果模块都由自己开发， 正常操作 \n\n![image.png](https://i.loli.net/2019/05/24/5ce7933994a0090037.png)\n\n但是因为不能改, 所以只能拦截：\n代码：\n```python\npythonPath = self.pythonPath_cb.currentText()\n\nif suffix == \"py\":\n    # 首次\n    self.pyCommand = [pythonPath, path]\n    self.modifiedReloadPython(path)\ndef modifiedReloadPython(self, path_):\n    os.chdir(os.path.dirname(path_))\n    # 子进程调用\n    self.p = subprocess.Popen(self.pyCommand, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    # self.stdoutWorker.p = self.p\n    self.stdoutWorker = Worker(self.p)\n    self.stdoutWorker.stdout_signal.connect(lambda x: self.error_te.append(\"PYDEBUG:\\n\" + x))\n    self.stdoutWorker.start()\nclass Worker(QThread):\n    stdout_signal = pyqtSignal(str)\n\n    def __init__(self, p, parent=None):\n        super().__init__(parent)\n        self.p = p\n\n    def run(self):\n        while True:\n            QApplication.processEvents()\n            if self.p is not None:\n                line = self.p.stdout.readline()\n                # line = line.strip()\n                if line != b'':\n                    try:\n                        info = line.decode()\n                        self.stdout_signal.emit(info)\n                    except:\n                        self.stdout_signal.emit(repr(line))\n    \n```\n","categories":[{"name":"随笔","path":"api/categories/随笔.json"}],"tags":[{"name":"Python","path":"api/tags/Python.json"},{"name":"subprocess.Popen","path":"api/tags/subprocess.Popen.json"},{"name":"拦截print","path":"api/tags/拦截print.json"}]}